<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[聊聊电影《杀生》]]></title>
    <url>%2F2020%2F10%2F04%2Fpetty%2Fflx%2F</url>
    <content type="text"><![CDATA[在微博刷到黄渤在《杀生》中的片段，本以为是一部喜剧片。看过后，后知后觉，这片子值得思考的真的特别多。 豆瓣有评论说和《让子弹飞》类似，虽然都是隐喻，但还是有本质的区别。《让子弹飞》中发哥那句”拿银子是贪，拿抢是反”其实已经对主题进行了很透彻的点拨。 我想，不同年龄段的人看《杀生》会有不同的感受，其实任何一部影片，一本书，一个故事，都会是这个规律。知乎有一位评论大意是，电影前半段喜剧，后半部分有无奈和温情，这是他的观点；当然这并没有错，这应该是电影给大多数人的第一印象。而我不忘的是任达华饰演的医生反复在问：他是怎么死的？ 所以，牛结实是怎么死的？ 其实电影已经交代得很清楚了，为了他和寡妇的孩子，自己喝下了村民准备给寡妇的药。但是，村民们真的希望牛结实死吗？ 答案是：不希望。电影中有交代，苏有朋饰演的牛医生说，杀了牛结实，一了百了，村民当即反对。大家只想赶走牛结实，并不想害他的性命。那么下一个问题，村民们如此憎恨牛结实，为何不呢？难道真的只是民风纯朴，村民们心底善良？ 电影最后牛结实挨家挨户告别村民，村民们在身后”送别”，牛结实转身跪求放过自己的孩子一幕确实感人。或许村民们送别的并不是牛结实，而是每个人内心真实的自己，为什么这么说呢！ 牛结实是长寿镇里的”异类”，跟着父亲”马三炮”流离失所至此。父亲患癌去世，牛结实从小在村子中长大，却完全不受村子中的世俗约束，他一个人”无视”压抑的世俗； 给即将死去的祖爷爷喝酒，让祖爷爷”满意”的离开，犯下村里的大忌，引起群愤； 他在全村人面前救下了陪葬的寡妇，在单身铁匠面前睡了铁匠朝思暮想的寡妇，还让寡妇怀上了自己的孩子； 当街逼着卖肉的三叔不要因为害怕老婆而改姓； 在村里朝拜的圣水中洗澡； 把春药倒在水中，让全村放飞自我； 刨别人祖坟，把陪葬的东西当做别人婚礼的大礼。…… 在封建世俗和规矩面前，牛结实做的每一件事，似乎都是不可饶恕的大逆不道，可即使如此，长寿镇的人至始至终都没有想要杀死牛结实，与其说没有想过杀害牛结实，甚至还想着各种理由来宽恕他——因为这些事是他们想做却不敢做的。 电影最后多次出现牛医生写的”境由心生”，境其实就是长寿镇，这个人皆长寿，清朝皇帝赐名的”长寿镇”，人们为了镇子的荣耀，生活循规蹈矩，这里规矩自成，生活压抑到扭曲。而牛结实唾弃这一切，他是镇子中唯一活得真实的人。而这份真实，也成了长寿镇唯一的闪光点，成为了镇子中所有人的内心真实表达。 所以，村民们告别的不是牛结实，而是他们内心中最真实的自己，告别的是长寿镇集体对自由和真实的向往，告别的是对封建最后的反叛。牛结实的死，不单是他一个人的死亡，是长寿镇集体精神的死亡。电影最后的巨石滚下，或许是想让长寿镇的人肉体也随精神死一次吧。 在某种体制下，做到真实的自己，不妥协，其实很难，能坚守初心，不被扭曲，已然难能可贵。惟愿将来的日子，还能有自己的信仰。 4天国庆结束了，浑浑噩噩，也难得有点自己的生活。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序—插入排序]]></title>
    <url>%2F2020%2F06%2F17%2Fprogramming-practise%2Fflx1%2F</url>
    <content type="text"><![CDATA[许久没有写点东西了，答辩之后人也变得松懈。今天看到简书又有人点赞之前记录的冒泡排序，点进去一看，居然有4w+的阅读量，心生疑问，咋会有这么高的阅读量，打开百度搜索冒泡排序，结果第3条就是我的。点开认真看了看，其实写得不好，还改了两个错别字(狗头)，这个阅读量或许只是记录的点击量。但我萌生一个想法，趁现在有时间，想把排序系列做完，便于以后自己回顾。 排序系列传递门排序—冒泡排序排序—选择排序排序—快速排序排序—插入排序排序-希尔排序（待完善）排序—归并排序（待完善）排序—基数排序（待完善）排序—堆排序（待完善）排序—桶排序（待完善）排序—计数排序（待完善）排序—排序算法总结（待完善） 插入排序思想基本思想是在一个有序的序列中找到待排序元素的位置，比如将3插入-1，2，4，6这个有序序列中，先与6和4比较，直到和2比较之后，找到适合插入的位置(2之后)。下面以按升序排序为例： step1 第一个元素默认有序。 step2 取待排序的元素B，在有序序列上从后往前寻找。 step3 如果已排序元素A大于待排序的元素B，则将A往后移动一位。 step4 重复step3，直到找到元素A&lt;=B(待排序)时或者有序序列全部被扫描。将待排序元素A插入。 重复step2—step4 动图展示(图片来源见参考资料) 代码实现(java)12345678910111213141516171819/** * 插入排序 * @param arr */ public static void insertSort(int[] arr) &#123; if(arr == null || arr.length == 0) return; int curEle, preIndex; // 记录当前待排序元素和前一个元素的下标 for(int i = 0; i &lt; arr.length; i++) &#123; preIndex = i - 1; curEle = arr[i]; while(preIndex &gt;=0 &amp;&amp; arr[preIndex] &gt; curEle)&#123; arr[preIndex + 1] = arr[preIndex]; // 移动元素 preIndex--; &#125; // 将待排序元素插入新的位置 arr[preIndex + 1] = curEle; &#125; &#125; 算法分析时间复杂度：$O(n^2)$空间复杂度：$O(1)$稳定性：稳定 参考资料值得收藏的十大经典排序算法 最后 本文若有不当，请指出。此致，敬礼！]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移AndroidX]]></title>
    <url>%2F2020%2F06%2F17%2FAndroid%2Fflx%2F</url>
    <content type="text"><![CDATA[1. 前言 AndroidX replaces the original support library APIs with packages in the androidx namespace. Only the package and Maven artifact names changed; class, method, and field names did not change.，Google不再对android support库进行维护，android support中的API由命名空间AndroidX下的软件包进行替换，即相应的包名和Maven工件名发生改变。 2. 迁移AndroidX2.1 迁移之前的准备 原有项目的support库版本升级至28(Android 9)，这也是support library的最后版本，SDK 28 和AndroidX 1.0 是等效的。This is because AndroidX artifacts with version 1.0.0 are binary equivalent to the Support Library 28.0.0 artifacts.， 1compileSdkVersion 28 建议使用Android studio 3.2或更高版本，(当前最新版已经到了4.0)。 gradle-wrapper.properties中Gradle插件版本不低于4.6。 1distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip 如果代码在版本控制器中，建议在单独的分支中迁移。2.2 执行迁移 在gradle.properties文件中添加下列项。 1234# Android 插件会使用对应的 AndroidX 库而非支持库。android.useAndroidX=true# Android 插件会通过重写现有第三方库的二进制文件，自动将这些库迁移为使用 AndroidX，但并不完全自动。android.enableJetifier=true 如果是AS 3.2或更高版本，则提供了一键迁移，选择菜单Refactor-&gt; Migrate to AndroidX，会提示备份当前工程，勾选Backup project as Zip file，可以自动帮你备份。 左下角提示，点击Do Refactor 3 迁移结果在一键迁移之后，gradle文件中implementation的所有support库被androidx替换，比如123implementation &apos;com.android.support:appcompat-v7:28.0.0&apos; 变为implementation &apos;androidx.appcompat:appcompat:1.0.0&apos; 相应类名也会发生改变123import android.support.v7.app.AppCompatActivity;变为import androidx.appcompat.app.AppCompatActivity; 所以，可以先看看上面两项结果，如果没有替换成功，可手动替换，相应替换可查阅官方提供的CSV格式的依赖库映射文件和类映射文件。 rebuild project，如果编译通过，那么恭喜你了，我反正是失败了。 4 迁移出错4.1 可手动纠正的错 有的文件中没能替换掉，需要按照上述两项映射手动替换。 检查gradle中通过implementation引入的库，比如implementation androidx.recyclerview:recyclerview:1.0.0&#39;，则一键迁移后导入的类为import androidx.appcompat.widget.RecyclerView;，需要替换为import androidx.recyclerview.widget.RecyclerView;，猜测只是全局替换掉support字样。因为类似还有GridLayoutManager、FragmentTransaction;`等。 4.2 第三方库冲突support库和androidx是不能共存的， 情况1 ：当迁移结束之后，理论上讲自己的项目使用的是androidx，但是老项目中导入了许多第三方的库，这些旧版本的库使用的是support。 情况2：这种情况发生在未进行迁移的项目中，由于导入了最新版的第三方库，而该库使用了androidx，也会报错。 解决方法： 情况1，更新第三方库到最新版本或使用androidx的版本，如果这个库没有使用androidx的版本，那就要找其他的方案代替吧（不知道是否是正确的解决方案）。 情况2：使用旧版本的第三方库。 总之，就是多build，根据异常信息解决问题。 5 参考资料AndroidX预览官方迁移教程谷歌开发者-是时候迁移至 AndroidX 了 本文若有出入，请指正！我是小小范同学。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序-冒泡排序]]></title>
    <url>%2F2020%2F06%2F06%2Fprogramming-practise%2Fckfv9ons0002xqxlpxyk71rgj%2F</url>
    <content type="text"><![CDATA[思想 基本思想: 冒泡排序，类似于水中冒泡，较大的数沉下去，较小的数慢慢冒起来，假设从小到大，即为较大的数慢慢往后排，较小的数慢慢往前排。 直观表达，每一趟遍历，将一个最大的数移到序列末尾。 算法描述 比较相邻的元素，如果前一个比后一个大，交换之。 第一趟排序第1个和第2个一对，比较与交换，随后第2个和第3个一对比较交换，这样直到倒数第2个和最后1个，将最大的数移动到最后一位。 第二趟将第二大的数移动至倒数第二位……因此需要n-1趟；动图实现，（来源参考资料）代码实现(java)123456789101112131415161718192021222324252627282930313233343536/** * @ClassName: BubbleSortMain * @Author: fanjiajia * @Date: 2019/3/4 下午9:15 * @Version: 1.0 * @Description: 冒泡排序 */import com.jiajia.ArrayUtil.*; // 按包名导入public class BubbleSortMain &#123; public static void main(String[] args) &#123; int[] arr = &#123;2,5,1,3,8,5,7,4,3&#125;; bubbleSort(arr); ArrayUtil.print(arr); &#125; /** * 冒泡排序 * @param arr */ private static void bubbleSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr.length - i -1; j++) &#123; // 这里说明为什么需要-1 if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; &#125;&#125; 复杂度 时间复杂度: $O(N^2)$空间复杂度: $O(1)$稳定性: 稳定 参考资料https://www.toutiao.com/a6593273307280179715/?iid=6593273307280179715 最后 此致，敬礼]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序-选择排序]]></title>
    <url>%2F2020%2F06%2F06%2Fprogramming-practise%2Fckfv9ons8003mqxlp87ymdoei%2F</url>
    <content type="text"><![CDATA[思想每一次遍历待排序的序列，记录最小（大）值的下标，和待排序第一个元素进行比较，如果小（大）与待排序第一个元素，交换动图实现：（参考资料） 实现(java)1234567891011121314151617181920212223242526272829303132333435363738/** * @Author: fanjiajia * @Date: 2019/3/1 下午9:05 * @Version: 1.0 * @Description:选择排序 */public class Main &#123; public static void main(String[] args) &#123; int[] arr = &#123;2,5,4,3,8,6,4&#125;; selectSort(arr); for (int i = 0; i&lt; arr.length; i++)&#123; System.out.print(arr[i] + &quot;,&quot;); &#125; &#125; /** * 选择排序 * @param arr */ private static void selectSort(int[] arr) &#123; for (int i = 0,k =0; i &lt; arr.length; i++, k = i)&#123; // 这一层查找后面最小值的下标 for (int j = i+1; j &lt;arr.length; j++) &#123; if (arr[k] &gt; arr[j]) &#123; // 这个改为小与符合即为从大到小 k = j; &#125; &#125; // 交换值 if( i != k) &#123; int temp = arr[i]; arr[i] = arr[k]; arr[k] = temp; &#125; &#125; &#125;&#125; 分析 时间复杂度：$O(N^2)$ 空间复杂度: $O(1)$ 稳定性： 不稳定参考资料http://p9.pstatp.com/large/pgc-image/153511583598984ab75e4cd最后 此致，敬礼]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序-快速排序]]></title>
    <url>%2F2020%2F06%2F06%2Fprogramming-practise%2Fckfv9ons30037qxlp6ifjhg4h%2F</url>
    <content type="text"><![CDATA[思想 快速排序每一趟排序，都会寻找一个基准元素，有的采用第一个元素，有的会随机生成一个，但是基本思想是不变的，一趟排序结束，会形成以基准元素为分界点的两部分，其中左边比基准元素小（假设从小到大排序），右边比基准元素大。然后再以相同的方法处理左边和右边两部分，即递归。 实现（java）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import com.jiajia.ArrayUtil.ArrayUtil;/** * @ClassName: QucikSortMain * @Author: fanjiajia * @Date: 2019/3/6 下午9:02 * @Version: 1.0 * @Description: 快速排序 */public class QucikSortMain &#123; public static void main(String[] args) &#123; int[] arr = &#123;4,2,35,9,7,8,1,5,0,4,3&#125;; quickSort(arr, 0, arr.length - 1); ArrayUtil.print(arr); &#125; private static void quickSort(int[] arr, int left, int right)&#123; if (left &gt;= right) &#123; // 必须加 return; &#125; int temp = arr[left]; // 以左边的元素为基准元素 int i = left, j = right; // i,j为两个游标 while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= temp)&#123; // 右边先走 j--; &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= temp) &#123; i++; &#125; if (i &lt; j) &#123; swap(arr, i, j); &#125; &#125; arr[left] = arr[i]; // 注意，这一步必须要，填上最左边的坑 arr[i] = temp; // 基准元素就位 quickSort(arr, left, i - 1); // 递归操作左边部分 quickSort(arr, i + 1, right); // 递归操作右边部分 &#125; /** * 交换两个元素 * @param arr * @param i * @param j */ private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 很多方法会写成两个函数，一个用来返回一趟结束后基准元素的位置，然后一个外围函数用来递归，其实和这个类似，其实就是将后面两个递归函数之前的部分封装成一个函数而已！ 参考资料快速排序（过程图解）白话经典算法系列之六 快速排序 快速搞定值得收藏的十大经典排序算法 最后 此致，敬礼]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不用USB数据线进行Android开发调试]]></title>
    <url>%2F2020%2F06%2F01%2Fkits%2Fflx1%2F</url>
    <content type="text"><![CDATA[不管是过去Eclipse还是现在的Android Studio开发Android，运行或者调试时都会利用USB数据线连接电脑和手机，特别是当现在的手机只有一个Type-c接口，意味着，插上后，啥也干不了了。 第一步首先还是用USB线连接电脑和手机，然后打开命令行，输入adb tcpip 4444； 4444为端口号，自己指定。 第二步断开USB线，找到自己手机的IP地址；然后在命令行中输入adb connect ip:4444 , 这里的ip是自己的手机ip地址！ok，搞定。 第三步如果需要退出调试，adb kill-server即可断开连接！ tcpip, 其实就是通过网络连接设备。]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Oracle通过一个字段的值将一条记录拆分为多条记录]]></title>
    <url>%2F2019%2F12%2F18%2FSQL%2Fflx1%2F</url>
    <content type="text"><![CDATA[前言 之前遇到了一次这样的需求，当时没有记录，这一次又赶上了，简单的记录一下。 本文个人拙见，若有出入，请指出——来自菜的颤抖该方式的效率不高，如何优化，请看记Oracle中regexp_substr函数的一次调优(速度提高99.5%) 场景表A中存放了集装箱的信息，一个集装箱一条记录，表B中存放了对于集装箱操作的指令，一条指令包括多个集装箱箱号，通过分号;切割（TCIU2347687;XUTR3546865），现在的需求是，对于已经在指令表B中的集装箱，在查询表A时需要过滤掉。 很容易想到的是not in, 然而分号分割。 其次，not like，然而[Err] ORA-01427: 单行子查询返回多个行,表示like后面只接受模糊查询的单个值。 所以必须将分号分割的记录，拆分成单独的记录。变成： 实现Oracle可使用regexp_substr函数实现，实现上面切割的sql为：12select regexp_substr(&apos;TCIU2347687;XUTR3546865&apos;, &apos;[^;]+&apos;, 1, level) JZXXHfrom dual connect by level &lt;= regexp_count(&apos;TCIU2347687;XUTR3546865&apos;, &apos;;&apos;) + 1 其中regexp_substr各个参数的含义： TCIU2347687;XUTR3546865 表示需要分割匹配的串（我这里只是做了示例，真实情况下是表的字段）。 [^;]+典型的正则表达式，我这里分号切割，因此确定分割规则是多个不是分号的字符，因此遇到分号便结束，完成一个串的获取。 1开始位置，最左端（Oracle下标都是1开始） level表示第几个匹配上的。为了直观点搞清楚这个函数，比如下面的语句：1select REGEXP_SUBSTR(&apos;aaa;bbb&apos;,&apos;[^;]+&apos;,1,1) AS STR FROM dual; 结果就是aaa, 如果把第二个1变成2，输出就是bbb。好了，这部分意图很明显了，下面就是把它每一个切割串取出来，看到上面取level个，而这个level是个什么东西呢，在这个之前，先看regexp_count（string, c）函数，这个函数其实很好理解，返回string中c的个数。然后就是这个level，这是一个伪列，和RowNum相似，1SELECT LEVEL FROM DUAL CONNECT BY LEVEL &lt;=2; 所以再回到最初的sql，也就很好理解了。 最后 此致，敬礼]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记Oracle中regexp_substr函数的一次调优(速度提高99.5%)]]></title>
    <url>%2F2019%2F12%2F18%2FSQL%2Fflx1%2F</url>
    <content type="text"><![CDATA[项目中需要做一个船舶代理费的功能，针对代理的船进行收费，那么该功能的第一步便是选择进行代理费用信息的录入，在进行船舶选择的时候，发现加载相关船舶信息十分的慢，其主要在sql语句的执行，因为测试的时候数据较少，实际使用中，数据量较大。 关于regexp_substr函数的使用可查看Oracle通过一个字段的值将一条记录拆分为多条记录 需求和表结构船舶相关的信息在系统中有船舶动态表（CBDT），另外有一张船舶代理费表（CBDLF），要求对于已经录入代理费的船舶不再出现在列表中（CBDLF表中有记录的需要过滤掉），CBDT中有一个合同清单字段，HTQD，该字段由分号”；”拼接多个合同，由于选了船舶，需要计算这个船上所有合同的作业量（拿合同字段和其他表做连接），因此需要切割，方便后继的作业量计算，需求引入就是这里——需要切割合同清单字段（HTQD），存在几个合同，就要将该行变成几条记录。 船舶动态表CBDT（肯定是省略的啦，哪有这么简单的表） CBBH HC HTQD 0001 191210 N20191202-xx;N20191203-xx 船舶动态表CBDLF CBBH HC Free 0001 191210 12534.23 原来的方案对于之前的sql，执行时间长达5秒多，最快也是4秒多，而且是只有一个月的数据。 看看原来的sql语句123456select CBDT.CBBH, CBDT.HC, regexp_substr(CBDT.HTBHQD,&apos;[^;]+&apos;, 1,LEVEL,&apos;i&apos;) HTTDBHFROM CBDT WHERE (CBDT.CBBH, CBDT.HC) not IN (SELECT CBBH, HC from CBDLFB) AND KBRQ &gt;= TO_DATE(&apos;2019-11-18&apos;, &apos;yyyy-mm-dd&apos;) and KBRQ &lt;= TO_DATE(&apos;2019-12-18&apos;, &apos;yyyy-mm-dd&apos;)connect by LEVEL &lt;=regexp_count(CBDT.HTBHQD, &apos;;&apos;) + 1 第一次尝试使用了not in，显然这满足要求，但事实是not in的效率是十分低下的，（当初在用的时候，我也不知道啊，手动捂脸），所以应该改成join，有了下面的sql1234567select CBDT.CBBH, CBDT.HC, regexp_substr(CBDT.HTBHQD,&apos;[^;]+&apos;, 1,LEVEL,&apos;i&apos;) HTTDBHFROM CBDT LEFT JOIN CBDLFB ON CBDT.CBBH = CBDLFB.CBBH and CBDT.HC = CBDLFB.HC WHERE CBDLFB.CBBH is NULL AND KBRQ &gt;= TO_DATE(&apos;2019-11-18&apos;, &apos;yyyy-mm-dd&apos;) and KBRQ &lt;= TO_DATE(&apos;2019-12-18&apos;, &apos;yyyy-mm-dd&apos;)connect by LEVEL &lt;=regexp_count(CBDT.HTBHQD, &apos;;&apos;) + 1 这样改了之后，基本维持在4秒左右，当然，这还是不能忍的啊。 第二次尝试通过改变时间，无论是延长还是缩短，sql执行的时间基本都在4秒左右，所以，目前的数据量对sql的影响不是很大了，那么肯定是sql本身的问题，去掉regexp_substr后，果然，只需要0.0xx秒的时间，所以基本确定了是这个函数的问题。开始度娘和谷歌。然而只找到了一个百度经验说性能问题，也没有说怎么解决。直到在谷歌上有人说，regexp_substr是正则，其本身效率就不高，不推荐。但是我的需求是必须要用啊（不知道有没有其他方案），找了许久依旧没有解决方案，回头再观察sql，regexp_substr是正则表达式毫无疑问，然后发现最后的regexp_count,这个那应该也是正则，但是regexp_count(CBDT.HTBHQD, &#39;;&#39;)的意思是计算有几个分号，这个函数可以换掉啊。所以改用了LENGTH(CBDT.HTBHQD) -LENGTH(REPLACE(CBDT.HTBHQD,&#39;;&#39;,&#39;&#39;)) + 1，运行，奇迹发生了。新的sql1234567select CBDT.CBBH, CBDT.HC, regexp_substr(CBDT.HTBHQD,&apos;[^;]+&apos;, 1,LEVEL,&apos;i&apos;) HTTDBHFROM CBDT LEFT JOIN CBDLFB ON CBDT.CBBH = CBDLFB.CBBH and CBDT.HC = CBDLFB.HC WHERE CBDLFB.CBBH is NULL AND KBRQ &gt;= TO_DATE(&apos;2019-11-18&apos;, &apos;yyyy-mm-dd&apos;) and KBRQ &lt;= TO_DATE(&apos;2019-12-18&apos;, &apos;yyyy-mm-dd&apos;)connect by LEVEL &lt;= LENGTH(CBDT.HTBHQD) -LENGTH(REPLACE(CBDT.HTBHQD,&apos;;&apos;,&apos;&apos;)) + 1 速度提到了约：67%。 1秒多的时间，虽然较原来的5秒要好太多，但是1秒多的卡顿，始终还是不好，那么继续尝试吧。 找新的方案去了，待更新……..(不到1秒内，誓不回)； ——————————————我是分割线—————————————— 我回来了，因为找到了终极优化，从5秒到0.025s，还是谷歌啊。最后执行时间话不多说，直接看改后的sql12345678select CBDT.CBBH, CBDT.HC, regexp_substr(CBDT.HTBHQD,&apos;[^;]+&apos;, 1,l) HTTDBH -- 原来的LEVEL换成了l，注意FROM CBDT LEFT JOIN CBDLFB ON CBDT.CBBH = CBDLFB.CBBH and CBDT.HC = CBDLFB.HC, (SELECT LEVEL l FROM DUAL CONNECT BY LEVEL&lt;=100) b -- 关键 WHERE CBDLFB.CBBH is NULL AND KBRQ &gt;= TO_DATE(&apos;2019-11-18&apos;, &apos;yyyy-mm-dd&apos;) and KBRQ &lt;= TO_DATE(&apos;2019-12-18&apos;, &apos;yyyy-mm-dd&apos;) AND l &lt;= LENGTH(CBDT.HTBHQD) -LENGTH(REPLACE(CBDT.HTBHQD,&apos;;&apos;,&apos;&apos;)) + 1 之前的connect 是使用到sql最后，这样的方式会导致数据出现很多冗余，而且冗余特别严重，需要使用distinct，至于原因，还在找。使用regexp_substr函数必须配对使用connect，但是没想到居然可以这样使用。 5—&gt;0.023 这速度提高99.5%；页面秒开，爽。 最后本文可在我的小站中查看记Oracle中regexp_substr函数的一次调优 生命不息，使劲造。]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android根据内网外网连接情况配置服务器访问IP]]></title>
    <url>%2F2019%2F11%2F06%2FAndroid%2Fflx%2F</url>
    <content type="text"><![CDATA[新项目的app，可通过内网和外网的服务器ip进行请求访问，但是客户提供了专业终端，终端在wifi情况下走外网内网都可以，但关闭wifi则只能走4G专网，也就是只能走内网。 方案Android中可以直接调用底层的shell，执行相应的命令，因此只需要执行ping命令即可。Android可以通过 Process p = Runtime.getRuntime().exec(/system/bin/ping -c 1 -w 1 &quot; + ip)执行。然后通过if (p.waitFor() == 0)判断是否ping通，这里的两个1表示参数，第一个表示ping 1次，第二个表示超过1s即为失败。 完整实现 首先声明权限，这一步非常重要，在AndroidManifes文件中 12&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 维持几个全局变量 12345String outer_ip = &quot;183.230.XXX.XXX&quot;; // 服务器外网IP String inner_ip = &quot;192.168.XXX.XXX&quot;; // 服务器内网IP boolean outerIpAvilable = false; // 外网可用 boolean innerIpAvialable = false; // 内网可用 开启两个线程去ping两个ip，并通过CountDownLatch控制同步。因为要在两个ping结束之后，配置了ip之后才能做接下来的操作。 1234567891011121314151617181920private void initNetworkConfig() &#123; try &#123; final int totalThread = 2; CountDownLatch countDownLatch = new CountDownLatch(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(new PingNetwork(outer_ip, countDownLatch, false)); executorService.execute(new PingNetwork(inner_ip, countDownLatch, true)); countDownLatch.await(); // 等待二者执行完毕 Log.d(TAG, &quot;end&quot;); if (innerIpAvialable &amp;&amp; outerIpAvilable) Toast.makeText(this, &quot;内外都可使用&quot;, Toast.LENGTH_SHORT).show(); else if (outerIpAvilable) Toast.makeText(this, &quot;外网可使用&quot;, Toast.LENGTH_SHORT).show(); else Toast.makeText(this, &quot;内网可使用&quot;, Toast.LENGTH_SHORT).show(); executorService.shutdown(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 实现ping的异步线程， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class PingNetwork implements Runnable &#123; String ip; // 需要ping的ip CountDownLatch countDownLatch; boolean isCheckInner; public PingNetwork(String ip, CountDownLatch countDownLatch, boolean isCheckInner) &#123; this.ip = ip; this.countDownLatch = countDownLatch; this.isCheckInner = isCheckInner; &#125; @Override public void run() &#123; try &#123; Process p = Runtime.getRuntime().exec(&quot;/system/bin/ping -c 1 -w 1 &quot; + ip);// ping网址3次 // ping的状态 final int status = p.waitFor(); if (status == 0) &#123; Log.d(TAG, &quot;ping onSuccess&quot;); if (isCheckInner)&#123; innerIpAvialable = true; outerIpAvilable = false; &#125; else&#123; outerIpAvilable = true; innerIpAvialable = false; &#125; &#125; else &#123; // 读取ping的error内容，查看无法ping通的原因 InputStream errorStream = p.getErrorStream(); BufferedReader errIn = new BufferedReader(new InputStreamReader(errorStream)); StringBuilder sb = new StringBuilder(); String err = &quot;&quot;; while ((err = errIn.readLine()) != null) &#123; sb.append(err); &#125; Log.d(TAG, &quot;result err : &quot; + sb.toString()); Log.d(TAG, &quot;ping onFailure&quot;); &#125; &#125; catch (Exception e) &#123; Log.d(TAG, &quot;ping onFailure&quot;); &#125; finally &#123; countDownLatch.countDown(); &#125; &#125; &#125; 这里在ping失败时候可以打印错误信息查看，还记得第一步是声明权限，本人没有声明第二个权限，在这里得到了一个错误信息Pemission denied，网上说什么root的都有，其实不然。 完善通过以上的实现，可以实现通过内网外网连接情况配置访问服务器的ip，但是设想一下，如果在app启动时，手机可以访问外网，所以程序配置了外网的ip（因为外网速度快），但是在使用的过程中，关闭了外网访问，比如说wifi，此时走了专网，即内网，则无法再访问服务器了。所以在切换网络时，需要从新配置访问ip。因此，需要再app里面通过广播的方式，在android N（android 7）之前，可以通过android.net.conn.CONNECTIVITY_CHANGE广播，可以静态注册和动态注册，然而在7之后，改广播无效了，可以使用以下方案替换。123456789ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); connectivityManager.requestNetwork(new NetworkRequest.Builder().build(), new ConnectivityManager.NetworkCallback() &#123; @Override public void onAvailable(Network network) &#123; super.onAvailable(network); LogUtil.d(&quot;网络发生改变，更改配置&quot;); NetworkUtils.initNetworkConfig(); &#125; &#125;); NetworkUtils.initNetworkConfig();是我对上面通过ping配置ip的封装。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[震惊，hexo个人博客居然有这么方便的评论系统]]></title>
    <url>%2F2019%2F11%2F01%2Fkits%2Fflx%2F</url>
    <content type="text"><![CDATA[论文搞得一头火，瞎倒腾了一下，没想到几分钟给自己的博客换了个评论系统。之前用的gitalk，需要依赖github，死活没有成功，而且评论者还需要登录github才可以评论，不好用，刚才偶然间发现valine，一步到位，可匿名评价。 配置 先去注册，valine依附于LeanCloud，先去注册，并完成实名认证LeanCloud注册 注册成功切记实名认证，反正他会自己提醒的，不完成也做不了下一步 实名认证后创建应用，应用名字啥的随便取。 然后获得appid，和keys，如下图： 然后下一步把你的博客域名写到安全中心。 打开next主题的config文件，找到valine配置，把你的appid和appkey填进去，重新hexo g，hexo d，一下，三分钟后，看看你的文章底部，简约而不简单的评论出来了。我的配置 12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: 手动打码 appkey: 手动打码 notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: come on baby # 来啊，快活啊 avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 如果没有出来，那就去找一下那里踩了坑吧。 总结一下配置简单，next主题自带。匿名评价，方便。 参考资料valine快速开始next第三方服务集成]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android—基于OpenCV+Android实现人脸检测]]></title>
    <url>%2F2019%2F10%2F31%2FAndroid%2Fflx%2F</url>
    <content type="text"><![CDATA[导读 OpenCV 是一个开源的跨平台计算机视觉库, 采C++语言编写，实现了图像处理和计算机视觉方面的很多通用算法，同时也提供对Python，Java，Android等的支持，这里利用Android下的接口，实现一个简单的人脸检测； 首先需要说清楚这里是人脸检测，不是人脸识别，网上很多资料说实现人脸识别，最后一看明明是人脸检测。人脸检测：是找出人脸，并标记出人脸。人脸识别：检测出人脸，并能够通过学习，给出人脸信息，比如，给定一个人脸A，通过学习，在之后的众多检测中能够找出人脸A，这才是人脸识别； 准备工作首先到http://opencv.org/releases.html下载相应的开发工具，我下载时latest version是3.4.1，选择Android pack。开发包比较大，我下载时已经300多M。下载后解压缩，得到如下目录结构；新建AS项目，OpenCVDemo，然后File &gt; New &gt; New Module，选择Import Eclipse ADT Project；把下载下来的目录下sdk/java 下的项目导入到项目里。此时生产的Module名称为openCVLibrary2411，版本不同这里名字会不同，后面添加依赖时，需要注意！ 然后将刚新建的这个modules 添加依赖到 app modules里，直接在 app 目录下build.gradle 文件里dependencies 下添加：1compile project(&apos;:openCVLibrary2411&apos;) 然后在 app/src/main 目录下创建一个jniLibs 目录，然后把sdk/native/libs 下全部文件 copy到jniLibs下，编译通过。 修改新建模块下 build.gradle 文件，把 compileSdkVersion 与 targetSdkVersion修改成你最新的SDK版本，如我的：123456789101112131415161718apply plugin: &apos;com.android.library&apos;android &#123; compileSdkVersion 27 buildToolsVersion &quot;26.0.2&quot; defaultConfig &#123; minSdkVersion 21 targetSdkVersion 27 &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.txt&apos; &#125; &#125;&#125; 我app下的build.gradle文件如下：123456789101112131415161718192021222324252627282930apply plugin: &apos;com.android.application&apos;android &#123; compileSdkVersion 27 defaultConfig &#123; applicationId &quot;com.jiajia.opencvdemo&quot; minSdkVersion 21 targetSdkVersion 27 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation &apos;com.android.support:appcompat-v7:27.1.1&apos; implementation &apos;com.android.support.constraint:constraint-layout:1.1.0&apos; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos; implementation project(&apos;:openCVLibrary2411&apos;)&#125; OK, 上面就是所有的准备工作； 实现人脸检测只需要有一个MainActivity即可，首先申请相应的权限12345&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;&lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;false&quot;/&gt;&lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; android:required=&quot;false&quot;/&gt;&lt;uses-feature android:name=&quot;android.hardware.camera.front&quot; android:required=&quot;false&quot;/&gt;&lt;uses-feature android:name=&quot;android.hardware.camera.front.autofocus&quot; android:required=&quot;false&quot;/&gt; 如果是Android是6.0以上，调用相机需要动态申请权限（小Demo，我直接在设置中为应用赋予了权限）； 修改MainActivity代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class MainActivity extends AppCompatActivity implements CameraBridgeViewBase.CvCameraViewListener&#123; private CameraBridgeViewBase openCvCameraView; private CascadeClassifier cascadeClassifier; private Mat grayscaleImage; private int absoluteFaceSize; private void initializeOpenCVDependencies() &#123; try &#123; InputStream is = getResources().openRawResource(R.raw.lbpcascade_frontalface); File cascadeDir = getDir(&quot;cascade&quot;, Context.MODE_PRIVATE); File mCascadeFile = new File(cascadeDir, &quot;lbpcascade_frontalface.xml&quot;); FileOutputStream os = new FileOutputStream(mCascadeFile); byte[] buffer = new byte[4096]; int bytesRead; while ((bytesRead = is.read(buffer)) != -1) &#123; os.write(buffer, 0, bytesRead); &#125; is.close(); os.close(); cascadeClassifier = new CascadeClassifier(mCascadeFile.getAbsolutePath()); &#125; catch (Exception e) &#123; Log.e(&quot;OpenCVActivity&quot;, &quot;Error loading cascade&quot;, e); &#125; openCvCameraView.enableView(); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); openCvCameraView = new JavaCameraView(this, -1); // 新建一个布局文件 setContentView(openCvCameraView); // 为该活动设置布局 openCvCameraView.setCvCameraViewListener(this); &#125; @Override public void onCameraViewStarted(int width, int height) &#123; grayscaleImage = new Mat(height, width, CvType.CV_8UC4); absoluteFaceSize = (int) (height * 0.2); &#125; @Override public void onCameraViewStopped() &#123; &#125; @Override public Mat onCameraFrame(Mat aInputFrame) &#123; Imgproc.cvtColor(aInputFrame, grayscaleImage, Imgproc.COLOR_RGBA2RGB); MatOfRect faces = new MatOfRect(); if (cascadeClassifier != null) &#123; cascadeClassifier.detectMultiScale(grayscaleImage, faces, 1.1, 2, 2, new Size(absoluteFaceSize, absoluteFaceSize), new Size()); &#125; Rect[] facesArray = faces.toArray(); for (int i = 0; i &lt;facesArray.length; i++) Core.rectangle(aInputFrame, facesArray[i].tl(), facesArray[i].br(), new Scalar(0, 255, 0, 255), 3); return aInputFrame; &#125; @Override public void onResume() &#123; super.onResume(); if (!OpenCVLoader.initDebug()) &#123; &#125; initializeOpenCVDependencies(); &#125;&#125; 简单分析: 首先onCreate方法中设置屏幕常亮.1getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON); 然后新建了一个布局openCvCameraView，这个布局文件是OpenCV封装好了，不需要我们重写布局文件，因为请看setContentView方法，这和平时我们写Activity是不一样的。12openCvCameraView = new JavaCameraView(this, -1); // 新建一个布局文件setContentView(openCvCameraView); // 为该活动设置布局 然后为这个布局类设置了回调监听, 因为我们的MainActivity实现了CameraBridgeViewBase.CvCameraViewListener，所以监听器就是本身；1openCvCameraView.setCvCameraViewListener(this); 实现了该监听器，就需要实现onCameraViewStarted onCameraViewStopped onCameraFrame这三个方法，具体实现的逻辑就在这三个方法中，涉及到很多数据知识，就不多说了(我也不是很懂！！！) 参考资料 Android 接入 OpenCV库的三种方式 最后 此致， 敬礼]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序—setTimeOut定时器的坑]]></title>
    <url>%2F2019%2F10%2F31%2Fwxxcx%2Fflx%2F</url>
    <content type="text"><![CDATA[背景 实验室需要将项目的app搬到微信的小程序上，终于知道为什么程序员是手艺人了，只要有需求，就要想方设法去填充这种需求，去年是小程序的元年了可以说，去年冬天一个叫跳一跳的小程序游戏出现在我的微信中，当时就觉得腾讯是真的牛皮。一时间很多的软件小程序版相继出现，各大微信公众号也开始关联小程序。小程序相比于app，有着独特的优势，其中最大的就是没有ios和android平台之分，但是同时也有局限，你给我开发个小程序王者荣耀试试。 定时任务微信小程序API中有两种定时任务 setInterval setTimeOut这两者都能实现定时任务，比如实现一个定时器，但是建议采用后者setTimeOut,理由是前者并不精确。详细请参考https://www.zhihu.com/question/20479535 setTimeOut用法不多说直接上：123var timerName = setTimeOut(function() &#123; //循环代码&#125;, delay) 这里在循环代码处做我们需要循环处理的逻辑，delay是延迟的毫秒数，5秒 = 5 * 1000，timerName是返回的定时器名称，有什么用，因为要取消这个定时器就需要给需要给出取消的定时器名称1clearTimeOut(timerName) 坑我有一个需求是每五秒获取一次位置123456789startReportHeart() &#123; var timerTem = setTimeout(function () &#123; that.heartReport(); &#125;, app.globalConfig.heart_delay) // 保存定时器name that.setData(&#123; timer: timerTem &#125;) &#125;, heartReport()就是获取位置信息，这样的效果是，只执行了一次。然后查看了一通资料，发现这个setTimeOut只是在delay毫秒之后执行代码，嗦嘎。那如何才能循环执行呢？——&gt;递归登场好吧，我的递归就是(错误代码)1234567891011startReportHeart() &#123; var timerTem = setTimeout(function () &#123; that.heartReport(); &#125;, app.globalConfig.heart_delay) // 保存定时器name that.setData(&#123; timer: timerTem &#125;) &#125;) that.startReportHeart() &#125;, 好像没有毛病啊，自递归调用，嗯，没毛病，但是，，，，情况就是，瞬间出现了堆栈溢出。哈哈哈哈哈哈哈。。。。。。。分析: 我在startReportHeart函数中开启了一个timer，5秒后开始执行，heartReport获取位置信息，此时直接递归调用自己，再开启一个timer，我的天，这么愚蠢的代码，是谁写的，没错就是我。手动捂脸。 在知道了原因之后，那么如何才能解决呢？我们需要5秒后在一次执行，对就是这个需求，那么自然就是在timer中调用自身啊。笨蛋。 正确代码:12345678910startReportHeart() &#123; var timerTem = setTimeout(function () &#123; that.heartReport(); that.startReportHeart() &#125;, app.globalConfig.heart_delay) // 保存定时器name that.setData(&#123; timer: timerTem &#125;) &#125;, 就这样完美。 总结有的时候，遇到的坑真的很想打自己一巴掌，但是解决坑的过程，并发现自己的愚蠢却是一件非常开心的事呢。这个过程也是十分的funning呢。小程序开发刚开始一周时间，是的，一周上手，一点一点，现在越来越顺手，虽然写的东西比较low，但是再一次印证了那句话，只有实践才是最好的学习方式。不要找什么从入门到精通，你会发现，这些都会让你从入门到放弃。 此致，敬礼]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序-腾讯地图显示偏差问题]]></title>
    <url>%2F2019%2F10%2F31%2Fwxxcx%2Fflx%2F</url>
    <content type="text"><![CDATA[背景 在小程序中使用map组件，可以调用腾讯地图的API，将一些固定的点标记到地图界面上，点的经纬度获取是通过android端百度地图API获取的，所以此时将这个位置点信息直接设置上去会出现偏差，而且偏差还比较大 小程序设置位置点关于如何在map组件上设置位置点，详细请查看腾讯官方文档首先看一下map组件：1&lt;map id=&quot;map&quot; longitude=&quot;113.324520&quot; latitude=&quot;23.099994&quot; scale=&quot;14&quot; controls=&quot;&#123;&#123;controls&#125;&#125;&quot; bindcontroltap=&quot;controltap&quot; markers=&quot;&#123;&#123;markers&#125;&#125;&quot; bindmarkertap=&quot;markertap&quot; polyline=&quot;&#123;&#123;polyline&#125;&#125;&quot; bindregionchange=&quot;regionchange&quot; show-location style=&quot;width: 100%; height: 300px;&quot;&gt;&lt;/map&gt; 其markers是需要设置在地图界面的位置点数组，数组中的元素就是一个对象。123456789101112131415markers: [&#123; iconPath: &quot;/resources/others.png&quot;, id: 0, latitude: 23.099994, longitude: 113.324520, width: 50, height: 50 &#125;, iconPath: &quot;/resources/others.png&quot;, id: 0, latitude: 23.094994, longitude: 113.424520, width: 50, height: 50 &#125;], 这里的latitude和longitude如果直接给其他地图定位的点，那么相同的这个点位置，在小程序中会出现偏差； 原因小程序中的定位方式默认的是wgs84,而百度地图中使用的是BD09 ，还有gcj02。所以这里会出现偏差。 解决方案使用离线的js库gcoord,将位置信息进行一次转换； 首先下载这个js库，放至某一个目录下，我这里是utils下 在需要的界面导入 1import gcoord from &apos;../../../utils/gcoord.js&apos; 调用转换函数 1234var result = gcoord.transform( [resArr[i].JD, resArr[i].WD], // 经纬度坐标 gcoord.BD09, // 当前坐标系（百度） gcoord.GCJ02); 这里在小程序中修改为gcj02,国测数据，因此转为gcj02； 最后 此致，敬礼]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下使用Charles抓包Android]]></title>
    <url>%2F2019%2F10%2F31%2Fkits%2Fflx%2F</url>
    <content type="text"><![CDATA[背景 一实验室同学问我学过爬虫没，会不会python，我说一点点，他找到一个”我去图书馆”自动抢座的python程序，让我给他跑起来，看到这个项目的github上说，需要在配置文件中添加自己的seesionID，这里的sessionID就是微信使用”我去图书馆”公众号时的ID，当然就需要采用抓包的形式进行获取。 Charles的安装 此软件的安装十分方便，直接在官网下载即可！此处选择相应的系统版本就可以！ Charles配置 安装好Charles之后，需要进行必要的配置 首先配置Proxy，如下图： 系统使用的端口是8888，通常不需要修改，当然也可以自己进行修改。 配置SSL Proxy，如下图一开始是没有任何项的，这里点击Addhost输入*, Port输入443.配置证书上面的操作以及可以抓一些http请求的包，但是现在很多请求都是https，因此需要安装相应证书，如下图：随后可以看到下图：这里需要信任Charles Proxy CA，我这里选择的是始终信任。 接下来需要为我们的移动端申请一个证书，如下图 到这里，电脑端的配置就全部结束了。接下来看移动端的配置 移动端配置 需要注意的是，移动端需要和pc端需要处于同一局域网内。 打开手机的wifi设置，点开已连接的Wi-Fi，设置代理为手动，主机名填pc端的ip，mac下用ifconfig查询，windows用ipconfig查询，端口号填8888(自己之前设置的端口) 然后用手机浏览器在地址栏输入chls.pro/ssl，它会提示下载一个证书，下载完毕后安装就可以。最后 我用的小米手机自带的浏览器下载的证书，是无法安装的，貌似小米手机都不行，网上各种说法，最后我下载了个234浏览器下载后安装成功。 使用完毕后记得把代理改回来，不然会上不了网的！]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C#WinForm中的一些小问题]]></title>
    <url>%2F2019%2F10%2F19%2FCplusplus%2Fflx1%2F</url>
    <content type="text"><![CDATA[前言 记一些C#窗体应用编程中的小问题。 DataGridView 设置Selected = true后实际选中行标依旧是第一行。通常通过this.dataGridView1.Rows[i].Selected = true;后，在实际显示的时候，确实第i被选中，然而通过CurrentRow取值都是第一行，而且查看选中行标确实0 解决12this.dataGridView1.Rows[i].Selected = true;this.dataGridView1.CurrentCell = this.dataGridView1.Rows[i].Cells[0]; // 关键 清除DataGridView默认选中通常在给DataGridView设置了DataSource后，会默认选中第一行。 解决在DataBindingComplete事件this.dataGridView1.ClearSelection();，也可以在其他地方调用清空选择行。 TextBox只接受数字输入比如只接受一个整数输入，实现KeyPress事件，其中实现1234private void textBox1_KeyPress(object sender, KeyPressEventArgs e)&#123; e.Handled = e.KeyChar != 8 &amp;&amp; !Char.IsDigit(e.KeyChar)&#125; 关于带有小数点的数字校验可查看winForm控制输入框只接受数字输入 DataGridView按照某一列排序后，一些现实效果丢失如果在DataGridView初始化时，设置了一些现实效果，比如说根据数据的不同设置不同的底色，但是在排序后底色就消失了。 解决实现Sorted事件，在该事件中重新设置显示效果。 关于DataGridView 的this.dataGridView.DataSource as DataTable 问题DataTable dt = this.dataGridView.DataSource as DataTable , 这句话可以将DataGridView的的数据转到dt中，其实dt所持有的引用就是DataGridView的数据源，也即dt如果发生了改变，DataGridView也会发生改变。 结果如果不希望dt的改变影响到datagridview，使用DataTable dt = (this.dataGridView.DataSource as DataTable).copy() DataTable排序问题DataTable可以在代码中设定按照一列或者多列排序 1dt.DefaultView.Sort = &quot;BH DESC&quot;; 按照编号降序排序（控制默认最小）, 注意此时的dt并没有按照意愿排序，因为还差一步1dt = dt.DefaultView.ToTable(); 需要重新ToTable(); DataTable 查询问题DataTable就“像”一张数据库表一样，可以进行查询操作1DataRow[] drs = dt.Select(&quot; BH is not null&quot;); // 查询BH不为空的记录 返回的是DataRow 数组 最后 未完，待续。。。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>winForm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[winForm控制输入框只接受数字输入]]></title>
    <url>%2F2019%2F10%2F19%2FCplusplus%2Fflx%2F</url>
    <content type="text"><![CDATA[背景 给导师上一节c#编写数据库应用程序的课，模拟ATM自助取款机的功能写了个winForm程序，关于金额的输入肯定是数字，因此避免输入格式不正确的数字带来异常，直接在输入时进行校验. 封装函数C#输入控件TextBox，该控件有一个KeyPress事件，就是键盘按下事件。因此可以监听该事件。1234private void textBox1_KeyPress(object sender, KeyPressEventArgs e) &#123; e.Handled = Common.CheckDigitFormat(this.textBox1, e); &#125; 这里在通用工具函数中将校验函数进行了封住，见下面:1234567891011121314151617181920212223242526272829303132333435363738/// &lt;summary&gt; /// 判断输入数字是否合理 /// &lt;/summary&gt; /// &lt;param name=&quot;tb&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static bool CheckDigitFormat(TextBox tb, KeyPressEventArgs e) &#123; bool flag = false; if (e.KeyChar != 8 &amp;&amp; !Char.IsDigit(e.KeyChar) &amp;&amp; e.KeyChar != 46) &#123; flag = true; &#125; // 小数点的处理 if (e.KeyChar == 46) &#123; if (tb.Text.Length &lt;= 0) flag = true; //小数点不能在第一位 else &#123; // 判断是否是正确的小数格式 float f; float oldf; bool b1 = false, b2 = false; b1 = float.TryParse(tb.Text, out oldf); b2 = float.TryParse(tb.Text + e.KeyChar.ToString(), out f); if (b2 == false) &#123; if (b1 == true) flag = true; else flag = false; &#125; &#125; &#125; return flag; &#125; 最后 此致，敬礼]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>winForm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019我的秋招]]></title>
    <url>%2F2019%2F10%2F17%2Fpetty%2Fflx%2F</url>
    <content type="text"><![CDATA[秋招正式结束，最后感谢百度给予的认可，真的有种受宠若惊。简单回顾一下秋招。也给出自己的面经，文章最后列出两个自己看的资料。 3月：挤出时间去找了几家实习，在毫无准备的情况下，因为知道不能出去实习，正是这几次被按在地上摩擦的面试经历，让自己清晰的认识到找工作需要好多好多东西。 9月：正式开始秋招，这期间每天都在焦虑中度过，尤其在字节二面挂收到感谢信，小米二面完未收到恭喜涵，特别是贝壳一轮游之后自己深深的陷入的自我怀疑，每天味觉不振，每晚都会醒好几次，人也变得更加消瘦。但是还得继续，不想面临一毕业就失业的尴尬局面，9月前半段疯狂笔试，中下旬疯狂面试，还记得打破记录的是一天面了5家，面完人都坐不住了，每天在外面，面试前的紧张，面完赶下一场的疲于奔命，有的时候真的感觉好无助，特别是19号那天中午在餐馆里吃了午餐，趴在那睡得那一会，真的想给我个offer，让我结束秋招吧。 转机：9月20日凌晨，像平常一样，凌晨两点左右醒来，发现邮箱里收到了vivo的录用函，那一刻真的很感动，很晚很晚了，激动得好久才睡着，白天下午就去了签约沟通会，还送了一个大礼包，真的很感谢。在那之后又收到了欢聚时代的口头offer，以及oppo的offer，就这样慢慢的好起来，心情和状态慢慢好转，到最后面试百度时，真的很放松。 总结一下面试的公司：vivo 欢聚时代 oppo 海康威视 百度 华为 收到offer，美团 小米 4399等消息，科大讯飞收到offer意向书怎么又通知无法进入下一阶段， 贝壳一面挂，字节二面挂，阿里一面挂，招银电话面挂，CVTE二面挂，快手、京东笔试不过，滴滴、爱奇艺、小红书、网易、老虎集团、酷狗、招银信用卡中心笔试之后无消息，猿辅导、keep面试没去，很抱歉。 最后：真心感谢这个过程中出现的每一个面试官，这个过程虽然很痛苦，但是对自己的积累真的很重要，后面面试中出现了很多内容都得到了前面面试官的点拨，非常感谢。也感谢那个疲于奔命的自己，即使面试冲突了，哪怕时间错过了，我也会毫不犹豫的赶过去，也感谢这些公司给了面试机会，特别是vivo和百度。 总结：关于秋招总结几点， 1 心态，被拒绝是难免的，一定要调整好心态，同时面试时适度紧张，想开点，心态是最重要的。 2 基础，每个学科的基础性知识要掌握好，秋招的过程是一个查漏补缺的过程，做好每一面问题的记录，后来恶补。 3 简历，简历上写的东西一定要好好理解透，如果被面试官发现你是真的只是会用，那会很被动，也不用理解很透，只需要了解个大概，核心概念要知道。 4 项目，简历上的项目要烂熟于心，最好介绍前要介绍一下应用背景。 5 技巧，从自我介绍开始，就要学会介绍自己擅长的，在回答问题的时候也要学会将面试官引导到自己会的领域。 6 关于手撕代码，其实现场手撕题目一般不会太复杂，多为链表、数组排序、查找、二叉树、字符串操作、海量数据操作等，面试官主要考察你的思路、代码风格等。最好掌握递归、动态规划等思想。如果写不出来，也就没有必要一直耗着，有思路说一下也行。 [toc] 实习3月19日阿里电话一面 强引用和弱引用。 HashMap实现。 ArrayList和LinkList的区别； 红黑树； 设计模式； View的绘制； 体会： 说话要有条理，要会组织。 基础知识要扎实。 要学会看源码，专注某一个方面的技术，懂得透彻才行！ 3月26日腾讯电话一面 异常，多线程，反射，什么地方使用，解决了什么问题！ 泛型，和c++模版的区别，泛型擦除。 activity和service的区别。 activity，fragment，view的区别，什么时候只能用activity，什么时候只能用fregment。 进程保活，为什么程序会死掉。 svn和git的区别。 体会： 想问题不能太久，不一定要一个具体的答案，重在分析！ 基础，基础，基础，平时积累！ 4月17日华为面试 StringBuilder和StringBuffer的区别，分别怎么扩容 画项目的一个结构 项目功能分块 广播分类，分类方式等，有序无序，如何让一个APP接收另一个APP指定的广播。 六种设计原则，用过哪些 23种设计模式，用了那些 hashmap实现原理 活动的四种启动模式，淘宝页面的方案 startservice和bindservice的区别 项目中是否使用异步，并发。 framework结构，画出来（懵逼）[你结构都不知道，写出来的东西只是能用，华为是做手机的，不是做Android的，继续懵逼] 如何报心跳13.内存泄漏，遇到的，如何处理的。 优酷（时间不记得了） RecyclerView 缓存机制，缓存多少个，为什么使用RecyclerView 微信小程序是如何运行起来的。 Gradle如何分模块编译。 秋招8月30日 平安科技 JVM分那几个部分 堆内寸和栈内存的区别 有哪些异常，怎么处理。 有哪些树结构，应用场景 数据库索引 9月2日 字节一面 Android 4大组件（英文），及其作用。 活动的启动模式和相应活动栈的变化 自定义view，界面是如何绘制到手机屏幕上的。 HashMap HashTable ConcurrentHashMap的区别。 HashMap中如何获得key的hash值，hashmap的负载因子是否可以改变。 时间复杂度和空间复杂度分析。 手撕字符串反转（摆手算法） 9月5日 字节二面(凉面) HTTP状态码（1，2，3……开头的分别代表什么意思，206了解吗） HTTPS和HTTP的区别，秘钥是如何交换的； 活动的四种启动模式，及其应用场景，问了singleTop的应用场景，没回答好（投的android岗，二面唯一的android问题） get和post的区别，如果参数只是字符串，可以用get代替post吗，我说不能，get参数长度受限，面试官：具体限制多少，（不知道） 4. Java的异常；（我居然答出除0是不可try的，笨死了） 浏览器输入网址，经历了什么。 DNS解析了解吗（只知道DNS解析是通过域名得到ip)； HashMap和HashTable的区别，平时项目都使用的谁？（以为不会再问计算机网络了，结果……） TCP和UDP的区别； 3次握手和4次挥手。 手撕单链表添加，删除，反转（比较easy，最后面试官问会不会断链）； 9月2日 小米一面 JVM 内存模型，简单点的堆栈理解 java四种引用在GC的表现 final finally finalize 区别 Http get post Android 消息机制，线程是如何确保其Looper只有一个的。 ThreadLocal view绘制，3个函数 Android 事件分发机制，三个函数，以及其中的调用关系。 9月4日 小米二面 手写字符串转数字（逐位解析，判断溢出）； Activity的生命周期函数和表现。 自定义view相关，其layout_width等属性如何影响其呈现。 bindService和startServie的区别和各自的应用场景。 HashMap和HashSet的实现。 volatile关键字的作用（讲到了java内存模型，面试官问我怎么了解到java内存模型的，我很诚实的说准备面试^~^）;使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 java代码在JVM上会乱序，为何（不会）-&gt;指令重排列 ； 几个线程池的线性个数设置，以及其如何管理生命周期； 装箱和拆箱如何实现-&gt;valueOf 和 xxxValue(xxx为相应包装类型对应的基本数据类型，比如int) 泛型如何实现； 项目难点、如何解决。 9月2日 阿里一面 内存泄露 Android 层面，Java层面的原因。 项目中的Thread如何管理，有没有封装相应的工具内。 ArrayList HashMap的区别。 栈和队列的区别，分别用数组和链表实现队列，比较区别。 有A、B两个二叉树，判断A树是否是B树的一个子树。 如何实现双向循环链表，Android中双向循环链表的使用。 有哪些排序，选择一个排序，介绍他的实现思想，如何分析排序效率（我答了时间复杂度和空间复杂度，继续追问，用空间换取时间，给了一个场景，如果用户的手机内存比较小512，如果用空间太多，会有什么影响）。 TCP和UDP的区别，QQ聊天，视频，游戏，那个对可靠性需求高，那些用了TCP。 Android中两种广播 静态广播和动态广播，有什么区别？（明明经常用，也知道，当时居然脑袋怎么突然就想不起来了——常驻和非常驻的区别）。 Android用到那些布局，（答了经常用的线性和相对，继续追问，那种会效率高点……） Thread AsyncTask IntenService 有什么区别。 是否用过Android的Sqlite，（学习用过，就没追问，估计知道我不会） Android xml布局三种复用的方式 include，merge，ViewStub的区别（我只知道前两种，也没用实际用过，没答上来）。 9月10日 招银电话一面 类加载，在什么时候加载一个类 类的初始化 ThreadLocal Android中的进程通信 消息机制，为什么一个线程要有一个looper，不能共享吗 Service运行在单独的进程还是UI进程 webview，混合开发 IntentService Binder参数限制 9月11日 贝壳一面（凉面） px sp dp 的区别 java内存模型，volatile关键字 long double int 安全性(大意是多线程操作那个类型的变量是安全的)，long double是如何存储的。 数据库索引，B+树叶子节点存储的信息 聚集索引和非聚集索引 海量数据排序。 指令重排列问题。 垃圾回收算法。 可回收分析，new一个对象是否可回收。 9月16日 海康威视一面 活动生命周期，活动的启动模式。 服务的启动方式，多次startService如果stop问题。 四大组件 为何不能在子线程中更新UI问题。 项目。 说一个你关注的公众号中的一篇文章。（剩下一些记不清了，总体较为基础） 9月17日 华为一面 项目 活动的四种启动模式。 C++ 申请内存的方式，如何释放内存（我只答了析构函数，面试官还提示了delete） 四大组件 android中java和一般的java有何区别（答得比较差，说了google针对android封装了许多东西，比如说AsyncTask等，然后android运行在Dalvik虚拟机，并不是普通的jvm上，同时字节码也不同，巴拉巴拉巴拉） 项目中是如何优化ZXing二维码扫描的。 java中的多线程池。 手撕一个android中多线程实现贪吃蛇的逻辑，在线程中获得上下左右方向，并更新UI（这里其实主要考察的是线程的使用，以及android中不能在子线程更新UI等）。 9月17日 华为二面 先介绍项目。 手撕一个字符串问题，在字符串a中找到字符串b第一次出现的位置，以及出现了几次（我闷头一想这不是kmp吗，结果写了后，面试官说，你直接substring不就行了，些什么kmp，那一刻，觉得自己挂了） 说说项目中如何处理数据库并发的。 如何解决sql注入攻击（我说了参数绑定，面试官似乎不怎么满意）。 内存泄露 如何优化二维码扫描（和一面面试官同样的问题） java中8大基本数据类型。 java泛型（还有些不大记得了） 9月17日 华为三面 先介绍项目，每一个都介绍，面试官对第一个比较感兴趣，叫我仔细给介绍，然后还和我探讨其中一些硬件方案。 有什么乐趣，我说看中超，面试官说我心脏很强大啊。 问了一下android中四大控件，不是说三面就是聊聊人生吗。 活动的启动模式，平时怎么使用的。（其他就是一些人生话题了） 9月17日 美团一面 项目，每一个项目，感觉美团一面全程挖项目。 画一下MVP模式，介绍MVP带来的好处。 手撕两个数组合并成一个数组，保持有序，写出空间和时间复杂度。 如何优化二维码扫描。 android的静态广播和动态广播大部分在聊项目，就项目中的一些点做了一些询问。 9月17日 美团二面 介绍项目 项目难点 微信小程序是如何运行起来的（我只说了从服务器上下载程序包，然后面试官问什么格式，我不知道，然后面试官就说其实就是一个zip，然后跑起来的是H5，这个介绍对我而言非常重要，因为百度面试管也同样问了我）。 问我做了很多上层应用的开发，那对算法和数据结构还掌握多少，我说数据结构还行，算法有点薄弱，然后他说那就写个算法吧，懵逼，写个n的阶层吧，一下觉得面试管又在逗我，最后写完，他说我只是看看你还记得递归不，我…….. 问了android其他的开发框架，以及新的开发语言Kotlin等等。 进程间通信方式 内存溢出 java内存模型 GC tcp和udp 9月17日 vivo技术面 介绍项目 android的消息机制 广播分类，静态广播和动态广播的区别。 android中的服务，可以在服务中做耗时操作吗。 你们是如何做进程保活的，介绍一些oom值。 将一个数组分成两部分，使其和相接近，我说了和接近就是做差接近于0，然后采用递归尝试着将一个数放到左边右边，面试官说那如果最后一个数很大呢，不会了……其实这个题应该用dp，采用背包问题思想。 聊了约瑟夫环问题，1-50个人，围成一圈，报数每9个出去，最后一个是谁，我说用循环单链表。还有一些记不清了。 9月18日 欢聚时代一面 聊项目 android 活动的生命周期和启动模式。平时用了哪些 android的消息机制 android的view绘制， android 的事件分发，三个主要的函数。 内存泄露 如何找到界面卡顿（当时不知道） java中四种引用，new一个对象会被回收吗 GC算法 手撕 找到一个链表的中间元素，找到倒数第k个，有什么高效的操作，没想出来。 tcp和udp 如何优化二维码扫描 如何做的进程保活 9月18日 科大讯飞一面 活动的生命周期。 项目 科大讯飞的语音合成你使用了，有什么问题，答了一些多音字读不准确。 介绍了OCR，介绍了Tesseract。还问我现在如果叫我继承一个OCR，识别手写体需要多久，我说很快，因为不需要训练数据集。科大讯飞可能在android端没什么大的投入，所以聊了一些其他的问题，也不怎么记得了。二面在技术上就画了一下后台的项目分层结构。 9月18日CVTE电话面试 进程保活和活动拉起，简历有写 如何优化二维码扫描，还聊到了微信的二维码扫描。 你怎么看C++和java，巴拉巴拉巴拉 java泛型 java四种引用 GC算法 volatile关键字 synchronized和reetrankLock awit和sleep的区别 为什么迅雷服务器下载会比浏览器快一点（叫我放开思想想一下，我说可能迅雷中间经过了他自己的服务器） https，对称加密和非对称加密 线程池和关键参数。 实时性要求很高的是游戏是tcp还是upd。 9月19日 百度一面 重新说一遍笔试题中的SparseArray和Hashmap的区别。 介绍项目 二维码扫描如何优化 Camera如何调焦 重载和重写的区别 如何在子类中调用父类的方法 介绍项目中的东西，将界面的结构画出来，特别是层级关系。 RecyclerView和ListView的区别 android的消息机制，Handler的构造函数有传入Looper的吗，Looper.prepare是干什么的。 开发一个微信小程序的过程是怎样的，微信小程序是如何运行起来的（此时真的很感激美团二面面试官） js是如何调用java代码的，我说了我用过WebView写过混合开发，懂一丢丢。 写布局文件时需要注意什么？如何优化。 微信小程序是基于什么运行的，我说了H5，面试官说其实就是一个浏览器跑了一个本地的网页，也就是H5。 9月19日 OPPO技术面 介绍项目 聊项目，面试官用过ZXing，所以对我用的ZXing以及优化这块非常感兴趣，还说二维码识别其实只需要部分信息就可以。再问我有没有从bitmap上下功夫，我说失败了。 什么是ANR 四大组件 广播的种类，以及使用。 android的消息机制。 view的绘制 内存泄露，使用什么检查，我说LeakCanary，他说LeaksCanary只能检查一些组件啥的，并不全面。 GC算法，GC Root中存放了那些信息。 标记-整理如何实现。 9月19日 欢聚时代二面主管面，没有多少技术问题，大多关注在项目上。 项目，难点，给面试官看了写的微信小程序。 二维码扫描优化如何做的。 前后台是如何分工的。 在培训用户中的难点是什么。 觉得把对用户培训的时间拿来学习算法和数据结构是不是要好很多？ 工作地点等等…… 9月19日 CVTE视频面（凉面）1 . 介绍项目 项目中用到了什么设计模式，打了单例模式和观察者模式 写一个观察者模式，写得不好，连观察者和被观察者都没有搞清楚。 介绍一下MVP，MVVM 介绍一下2018年google开发者大会上提出的AAC（完全不知道，哎） java中的四种引用 Android各个版本的新特性。 LeaksCanary原理，还有用过其他的内存泄漏检测工具吗 okttp源码了解吗其他的不记得了 9月20日 百度二面（这是我遇到最新颖的面试，面试官抛出概念，我自己讲，能讲多少讲多少） 深挖简历上的各种了解。 讲一下okttp，那些关键的对象，同步和异步的访问函数。client是那个client ButterKnift如何使用，需要注意那些问题 DataBinding如何使用，了解其实现原理吗，你都不用MVVM，你用DataBinding干什么。 讲一下AIDL，说说进程间通讯方式。 除了GPS定位还有什么定位，我说网络定位，问我如何实现，我说不知道，他开导说手机连接着什么嘛，我说基站，然后一通巴拉巴拉，不知道自己说了啥。 讲一下二维码扫描的优化 说一下如何做到进程保活的，什么是oom值，以及JobScheduler 学过C++吗 jvm内存分区，栈溢出发生在那 手撕 从先序遍历和中序遍历复原原来的二叉树 手撕 快排 插入排序 https的机制，加密，证书秘钥交换等。 android 的消息机制， view绘制 事件分发流程，拦截函数叫什么，用没用过事件分发。 学android看了那些书，《第一行代码》有多少页，第一行代码和开发者探秘有那些内容。 布局优化。 9月22日 百度三面主管面，一半人生一半技术吧，最后介绍了20多分钟目前他所在的部门所在做的东西，真的超乎了我这种菜鸡的想像啊。 聊项目，很细很细 很关注二维码扫描优化这块，有没有在bitmap上下功夫。 为什么做进程保活和活动拉起 为什么地图用百度的，语音合成用科大讯飞的，我说做了一些比较，发现百度的在某些多音字上读不正确。其他的就是一些人生话题，三面感觉真的很nice。 资料java 计算机网络 操作系统等Android相关大神整理的剑指Offer]]></content>
      <categories>
        <category>杂记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于C#的DataGridView设置了DataSource后Rows无值问题]]></title>
    <url>%2F2019%2F08%2F22%2FCplusplus%2Fflx1%2F</url>
    <content type="text"><![CDATA[前言 今天写一个导出到Excel表的东西，以前也写过，之前导出都是将界面上的DataGridView中数据导出，没有任何问题，然而今天的导出场景是在界面是点击导出按钮，直接在数据库中查询符合条件的数据导出，不需要显示在界面上。 本文若有出入，请指正——来自小渣渣的颤抖客官可移步小站查看本文http://fanjiajia.cn/2019/07/08/Cplusplus/flx1/ 实现及问题直接看解决即可 实现因为项目中有公用的导出方法，只需要传递一个DataGridView参数即可，所以肯定是将查出来的DataTable转成一个DataGridView，以前都是直接在WinForm中拖，现在肯定是直接new一个。123456789101112131415// 新建一个DataGridView对象DataGridView dgv = new DataGridView(); // 添加列DataGridViewTextBoxColumn col_HTBH = new DataGridViewTextBoxColumn();col_HTBH.Name = &quot;ZXHTBH&quot;;col_HTBH.DataPropertyName = &quot;ZXHTBH&quot;;col_HTBH.HeaderText = &quot;合同编号&quot;;dgv.Columns.Add(col_HTBH);...... // 查询导出数据DataTable dt = BLL.YardSystem.DC.QueryQKHWXX();// 为dgv设置数据源 dgv.DataSource = dt; // 导出数据 ....... 按照上面的逻辑，new的dgv，添加的列设置了列名称，列的DataPropertyName,设置了该属性就能实现DataTable中对应的列匹配上。 问题做好了上面的工作，第一次运行，导出成功后，查看Excel表，没有数据，除了每一列的名称，debug，DataTable确实有数据，dgv的DataSource也有数据，然而却发现它的RowsCount为0，What。RowsCount为0。 解决一通捣腾，有人说绑定了但是没有填充，也有人说循环为一行赋值，一看就觉得low，最后看到一个哥们说把dgv添加到Controls里面，当时我还郁闷，我又不需要他显示，加进去干啥，然而就是这个不知道干啥起作用了。1this.Controls.Add(dgv)； Perfect，搞定，也不知道为什么，就是需要做这样一个操作。 最后 此致，敬礼]]></content>
      <categories>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于SQL中的ROWNUM问题]]></title>
    <url>%2F2019%2F08%2F16%2FSQL%2Fflx1%2F</url>
    <content type="text"><![CDATA[前言 昨天改小程序的后台，看见之前写的分页很奇怪，startIndex和endIndex两个下标, endIndex 总是在里面层，而startIndex总是在外层，我随后改了，直接Where rownum &gt; startIndex and rowmnum &lt;=endIndex, 结果只查出来了第一页，后面页查不出来了。 原因Where rownum &gt; 0 and rowmnum &lt;=20,是可以查出前20条记录的，但是Where rownum &gt;1 and rowmnum &lt;=20,就不行了，所以只要是rownum&gt;1都不可以。 上网查一番，原来ROWNUM作为一列虚列，也叫做伪列，总是从1开始，我知道这样说肯定觉得是废话。举个例子，where rownum &gt; 1, 结果是查不出数据，原因很简单，rownum总是从1开始，可以这样理解，查询过程即为从数据库的某一个数据区取值，第一行的rownum为1，第二行为2，但是限制条件where rownum &gt; 1导致第一行数据不符合条件，被丢弃，此时取第二行数据，然而此时，rownum仍然从1开始，因为之前哪一行丢弃了，rownum依旧从1开始，因此，永远取不到数据。 最后 此致，敬礼]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序实现左侧滑栏]]></title>
    <url>%2F2019%2F08%2F16%2Fwxxcx%2Fflx1%2F</url>
    <content type="text"><![CDATA[前言 一直想给项目中的小程序设置侧滑栏，将退出按钮放到侧滑中，但是小程序没有提供相应的控件和API，因此只能自己手动实现，网上很多大神造的轮子很不错，本文就在是站在巨人的肩膀上实现。 hexo图片不显示问题，可前往简书效果先看看效果，我的侧滑栏需要列出如下信息： 初始状态下，左下角设置悬空按钮 点击悬空按钮，侧边栏拉出，悬空按钮旋转180度 主页内容向右滑动一定比例，并设置阴影遮罩实现首先将xml文件分为三部分，一部分是主页内容，一部分是侧滑栏内容，一部分是悬浮按钮。123456789101112131415161718192021222324252627282930313233343536&lt;!--index.wxml--&gt;&lt;view&gt;&lt;!-- 侧边滑动菜单 --&gt; &lt;view class=&quot;page-slidebar&quot;&gt; &lt;view class=&quot;page-content&quot;&gt; &lt;view class=&quot;userinfo&quot;&gt; &lt;button wx:if=&quot;&#123;&#123;!hasUserInfo &amp;&amp; canIUse&#125;&#125;&quot; open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt; 点击获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap=&quot;bindViewTap&quot; class=&quot;userinfo-avatar&quot; src=&quot;&#123;&#123;userInfo.avatarUrl&#125;&#125;&quot; mode=&quot;cover&quot;&gt;&lt;/image&gt; &lt;text class=&quot;userinfo-nickname&quot;&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;view class=&quot;account-info&quot;&gt; &lt;view class=&quot;account-info-item&quot;&gt;用户：&#123;&#123;YHMC&#125;&#125;&lt;/view&gt; &lt;view class=&quot;account-info-item&quot;&gt;账号：&#123;&#123;YHZH&#125;&#125;&lt;/view&gt; &lt;view class=&quot;account-info-item&quot;&gt;角色：&#123;&#123;YHJS&#125;&#125;&lt;/view&gt; &lt;view class=&quot;account-info-item&quot;&gt;版本：&#123;&#123;version&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;view&gt; &lt;view class=&apos;quit-view&apos;&gt; &lt;button class=&apos;quit-btn&apos; bindtap=&apos;quit&apos;&gt;退出登录&lt;/button&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;!-- 主页内容 --&gt; &lt;view bindtouchmove=&quot;tap_drag&quot; bindtouchend=&quot;tap_end&quot; bindtouchstart=&quot;tap_start&quot; class=&quot;page-top &#123;&#123;open ? [&apos;c-state&apos;,&apos;cover&apos;] : &apos;&apos;&#125;&#125; &quot;&gt; &lt;view class=&quot;usermotto&quot;&gt; &lt;text class=&quot;user-motto&quot;&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;!-- 添加侧拉悬浮按钮 --&gt; &lt;view bindtap=&quot;openSlider&quot;&gt; &lt;image class=&quot;floatbutton &#123;&#123;open ? &apos;c-button-open&apos; : &apos;&apos; &#125;&#125;&quot; src=&quot;../../img/floatbutton.png&quot;&gt;&lt;/image&gt; &lt;/view&gt;&lt;/view&gt; wxss文件，样式文件中，主要是.c-state,.c-button-open,.cover三个样式。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/**index.wxss**/.userinfo &#123; display: flex; flex-direction: column; align-items: center;&#125;.userinfo-avatar &#123; width: 128rpx; height: 128rpx; margin: 20rpx; border-radius: 50%;&#125;.userinfo-nickname &#123; color: #aaa;&#125;.account-info &#123; margin-top: 50rpx;&#125;.account-info-item &#123; display: flex; align-items: center; height: 54px; margin-left: 10rpx; border-bottom: 1px solid #eee;&#125;/* 侧边栏样式 */.page-slidebar &#123; height: 100%; width: 65%; position: fixed; background-color:white; z-index: 0;&#125; /* 主页样式 */.page-top &#123; height: 100%; position: fixed; width: 100%; background-color:white; z-index: 0; transition: All 0.4s ease; -webkit-transition: All 0.4s ease;&#125;/* 控制侧边栏的内容距离顶部的距离 */.page-content &#123; padding-top: 60rpx;&#125;/* 当屏幕向左滑动，出现侧边栏的时候，主页的动画样式 *//* scale：取值范围 0~1 ，表示屏幕大小是原来的百分之几，可以自己修改成 0.8 试下*//* translate(60%,0%) 表示向左滑动的时候，侧边栏占用平时的宽度为 60% */.c-state &#123; transform: rotate(0deg) scale(1) translate(65%, 0%); -webkit-transform: rotate(0deg) scale(1) translate(65%, 0%);&#125;.floatbutton &#123; position: fixed; width: 100rpx; height: 100rpx; bottom: 140rpx; left: 40rpx; z-index: 9999;&#125;.c-button-open &#123; transform: rotate(180deg) scale(1) translate(65%, 0%); -webkit-transform: rotate(180deg) scale(1) translate(65%, 0%); transition-duration:0.5s; -webkit-transition-duration: 0.5s; left: 60%;&#125;/* 遮盖层样式 */.cover&#123; width: 100%; height: 100%; background-color:gray; opacity: 0.5; z-index: 9000;&#125;.quit-view &#123; height: 5%; width: 65%;&#125;.quit-btn &#123; position: fixed; bottom: 5rpx; z-index: 999; color: #fff; width: 65%; border-radius: 5rpx; background-color: #064acb;&#125; js文件，这里不涉及我demo中申请用户信息内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445// 点击左下角小图标事件 openSlider: function (e) &#123; if (this.data.open) &#123; this.setData(&#123; open: false &#125;); &#125; else &#123; this.setData(&#123; open: true &#125;); &#125; &#125;, tap_start: function (e) &#123; // touchstart事件 // 把手指触摸屏幕的那一个点的 x 轴坐标赋值给 mark 和 newmark this.data.mark = this.data.newmark = e.touches[0].pageX; &#125;, tap_drag: function (e) &#123; // touchmove事件 this.data.newmark = e.touches[0].pageX; // 手指从左向右移动 if (this.data.mark &lt; this.data.newmark) &#123; this.istoright = true; &#125; // 手指从右向左移动 if (this.data.mark &gt; this.data.newmark) &#123; this.istoright = false; &#125; this.data.mark = this.data.newmark; &#125;, tap_end: function (e) &#123; // touchend事件 this.data.mark = 0; this.data.newmark = 0; // 通过改变 opne 的值，让主页加上滑动的样式 if (this.istoright) &#123; this.setData(&#123; open: true &#125;); &#125; else &#123; this.setData(&#123; open: false &#125;); &#125; &#125; 参考资料 微信小程序之侧边栏滑动实现（附完整源码) 微信小程序侧边栏滑动特效(左右滑动)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[粒子群优化算法(PSO)及其java实现]]></title>
    <url>%2F2019%2F08%2F13%2FAlgorith%2Fflx2%2F</url>
    <content type="text"><![CDATA[憋了两周终于把开题报告憋出来了，再一次证明自己不适合搞学术，哎……，花了点时间把报告中提到的粒子群算法看了看，看了些资料，用java跑起来。若图片无法显示，可前往简书 算法简介粒子群算法最先由Barnhart博士和Kennedy博士于1995 年提出，是一种源于对鸟群捕食行为的研究而发明的进化计算技术，原理是模仿鸟群寻觅食物的搜索过程，设想鸟群在一定区域搜寻食物，在不知道食物确切位置的情况下，鸟群依靠群体中个体判断距离食物的远近程度来调节飞行方向和飞行速度，最终通过群体的经验和自身记忆的智慧找到食物。 算法原理算法描述 算法流程图 算法的实现(java) Particle.java文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.jiajia.pso;import java.util.Random;/** * @ClassName: Particle * @Author: fanjiajia * @Date: 2019/5/13 上午11:01 * @Version: 1.0 * @Description: */public class Particle &#123; //维数 public int dimension = 2; //粒子的位置 public double[] X = new double[dimension]; //局部最好位置 public double[] pbest = new double[dimension]; //粒子的速度 public double[] V = new double[dimension]; //最大速度 public double Vmax = 2; //适应值 public double fitness; /** * 根据当前位置计算适应值 * @return newFitness */ public double calculateFitness() &#123; //1.Ackley&apos;s function: //double newFitness = -20*Math.pow(Math.E,(-0.2*Math.sqrt(0.5*(X[0]*X[0]+X[1]*X[1]))))-Math.pow(Math.E,(0.5*(Math.cos(2*Math.PI*X[0])+Math.cos(2*Math.PI*X[1]))))+Math.E+20; //2.Sphere function //double newFitness = X[0]*X[0]+X[1]*X[1]; //3.Rosenbrock function double newFitness = 100*(Math.pow((X[1]-X[0]*X[0]),2))+Math.pow((X[0]-1), 2); return newFitness; &#125; /** * 初始化自己的位置和pbest */ public void initialX() &#123; for(int i=0;i&lt;dimension;i++) &#123; X[i] = new Random().nextInt(50); pbest[i] = X[i]; &#125; &#125; /** * 初始化自己的速度 */ public void initialV() &#123; for(int i=0;i&lt;dimension;i++) &#123; double tmp = new Random().nextDouble();//随机产生一个0~1的随机小数 V[i] = tmp*4+(-2); &#125; &#125;&#125; PSO.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package com.jiajia.pso;import java.util.ArrayList;import java.util.List;import java.util.Random;import java.io.File;import java.io.FileWriter;import java.io.IOException;/** * @ClassName: PSO * @Author: fanjiajia * @Date: 2019/5/13 上午11:02 * @Version: 1.0 * @Description: */public class PSO &#123; private static double[] gbest;//全局最优位置 private static double gbest_fitness = Double.MAX_VALUE;//全局最优位置对应的fitness private static int particle_num = 20;//粒子数 private static int N = 500;//迭代次数 private static int c1,c2 = 2; private static double w = 1.4;//惯性因子 private static List&lt;Particle&gt; particles = new ArrayList&lt;Particle&gt;();//粒子群 private static List&lt;Double&gt; fittessList = new ArrayList&lt;&gt;(N); /** * 主程序入口 * @param args */ public static void main(String[] args) &#123; process(); &#125; /** * 初始化所有粒子 */ public static void initialParticles() &#123; for(int i=0;i&lt;particle_num;i++) &#123; Particle particle = new Particle(); particle.initialX(); particle.initialV(); particle.fitness = particle.calculateFitness(); particles.add(particle); &#125; &#125; /** * update gbest */ public static void updateGbest() &#123; double fitness = Double.MAX_VALUE; int index = 0; for(int i=0;i&lt;particle_num;i++) &#123; // 找到群体中适应值最小的粒子 if(particles.get(i).fitness&lt;fitness) &#123; index = i; fitness = particles.get(i).fitness; &#125; &#125; if(fitness&lt;gbest_fitness) &#123; // 如果个体适应值小于全局适应值，更新全局的最优值为个体最优值 gbest = particles.get(index).pbest.clone(); gbest_fitness = fitness; &#125; &#125; /** * 跟新每个粒子的速度 */ public static void updateV(int n) &#123; for(Particle particle:particles) &#123; for(int i=0;i&lt;particle.dimension;i++) &#123; double v =(0.9 - n*(0.9-0.4)/N) * particle.V[i]+c1*rand()*(particle.pbest[i]-particle.X[i])+c2*rand()*(gbest[i]-particle.X[i]); if(v&gt;particle.Vmax) // 判断速度是否超过最大的速度 v = particle.Vmax; else if(v&lt;-particle.Vmax) // 比最大速度的相反数小 v = -particle.Vmax; particle.V[i] = v;//更新Vi &#125; &#125; &#125; /** * 更新每个粒子的位置和pbest */ public static void updateX() &#123; for(Particle particle:particles) &#123; for(int i=0;i&lt;particle.dimension;i++) &#123; particle.X[i] = particle.X[i] + particle.V[i]; &#125; double newFitness = particle.calculateFitness();//新的适应值 //如果新的适应值比原来的小则跟新fitness和pbest if(newFitness&lt;particle.fitness) &#123; particle.pbest = particle.X.clone(); particle.fitness = newFitness; &#125; &#125; &#125; /** * 算法主要流程 */ public static void process() &#123; int n = 0; initialParticles(); updateGbest(); while(n++&lt;N) &#123; updateV(n); updateX(); updateGbest(); fittessList.add(gbest_fitness); System.out.println(n+&quot;.当前gbest:(&quot;+gbest[0]+&quot;,&quot;+gbest[1]+&quot;) fitness=&quot;+gbest_fitness); &#125; write2File(); &#125; /** * 返回一个0~1的随机数 * @return */ public static double rand() &#123; return new Random().nextDouble(); &#125;&#125; 代码参考了其他资料，后面有说明，但是对其中部分进行了改进。 在Particle（粒子类）中设定了三个适应函数，Ackley,Sphere,Rosenbrock,关于这三个函数的介绍可以参考测试函数，这里面列出来了很多优化测试函数，很多的paper在设计了优化策略或者改进相应的优化策略之后，都会利用其中的函数进行测试。这里用到的函数是Rosenbrock:可以看出这里最小值在（1，1，，，1）处取的。为了看到相应的效果，这里将全局适应值写到txt文件中，并利用python绘制出来（莫名的感觉繁琐，要是python，哪有这么麻烦，只可惜最后的实验都是java写）。上面是$w$为1时，即惯性系数为1时的收敛结果，可以看出，算法前期搜索很快，后期较慢，且偶尔会陷入局部最优解里面。 惯性因子w的优化惯性因子$w$代表受上一次粒子速度的影响程度，$w$越大，收敛越快，但容易错过最优解。$w$越小，收敛较慢，容易陷入局部最优解，出不来。因此改进$w$成为很多改进的焦点，其中采用较多的是Shi建议的线性递减权值策略，通常将$w$设定在[0.4，0.9]之间：采用线性递减权值策略后得到的收敛效果：可以看出前期收敛直线下降，且不容易陷入局部最优，最后达到全局收敛。除了上面的线性递减权值策略，还有自适应权值策略，随机权重策略。详见参考资料[4]; 参考资料 粒子群算法原理及Matlab实现 基本PSO算法实现(Java) Y.Shi. A Modified Particle Swarm Optimizer. 1998 Test functions for optimization 武装. 几种改进的智能优化算法及其应用[M].科学技术文献出版社, 2018.最后 生命不息，生活好难！！！]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android填坑—Error:Execution failed for task ':app:transformClassesWithDexForRelease']]></title>
    <url>%2F2019%2F08%2F13%2FAndroid%2Fflx2%2F</url>
    <content type="text"><![CDATA[昨晚正在干着自己的事，另外一个同学说项目打包不了，但是可以debug运行。又急着需要打包apk发给那边人去测试。真的是搞事情，赶紧打开项目试试打包 。项目从之前的$Eclipse$中转过来的，清楚的记得当时转成功后第一件事就是测试能不能编译运行，第二就是尝试打包自动更新。确定当时没有问题，但是之后在上面又开发了些东西，gradle加了一些包啊啥的。 错误打包过程特别慢，那个圈一直转，我还将网切换到了自己的手机热点，因为我知道实验室的网会导致有的包下载不了，但是最后打包了半天，失败了。。。。开始各种搜索。。。。。。。。。。 填坑过程（可直接看后面的解决） 网上确实有很一些帖子啊，就说需要defaultConfig下添加multiDexEnabled true,这句话是干什么用的呢，就是分包，为什么需要分包呢，因为工程的方法数超过了64k，详见我的另外一篇文章Android工程方法数超过64K。这就说明我是有这句话的，而且看看报错异常中确实有multi的字样。而这个确实也是后来转为Androif Studio后加的，所以基本问题就定位到这里了。 所以去掉了这个分包功能（我知道去掉肯定会无法运行，只是想看看打包apk的时候会不会报这个error），事实证明，直接提示方法数超过64k，编译不过，我真是天真。 去看了看添加的gradle配置1implementation &apos;com.android.support:multidex:1.0.1&apos; 果然上面提示最新版本1.0.3，好吧，我改成最新版本，重写gradle下载，这个时候就出现了一转圈，我去打开了External Liberaies看看，结果发现了这个不对啊，我明明是1.0.3,怎么下载了1.0.2，一脸懵逼，猜想是我使用的compileSdkVersion 27,1.0.3需要更高版本吧，个人猜想而已。我又改成了1.0.2，最后满怀期待的打包，啪，，，异常依旧。心死。。。 想着今天晚上可能打包不了了，哎，仔细看看异常。 注意到了这句话1java.lang.OutOfMemorayError:GC overhead limit exceed 内存溢出，GC出问题了？？？？，难道这不应该是跑程序会出的问题吗，搞笑，copy，百度，一通搜索后，这样一句话映入眼帘.1javaMaxHeapSize &quot;4g&quot; 这句话写在app.gradle的dexOptions下，字面意思，指定堆大小4g，联想到内存溢出。先不管，搞上去，试一试打包。Perfect。。。。。。。。unbelievable。。。amazing。。。。 解决在在app.gradle的buildTypes的dexOptions下添加1javaMaxHeapSize &quot;4g&quot; 当然可以设定更大一些，似乎根据自己的pc配置来的。 最后 生命不息，使劲造]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小白用Android MVP-初体验（一）]]></title>
    <url>%2F2019%2F08%2F13%2FAndroid%2Fflx2%2F</url>
    <content type="text"><![CDATA[写android以来，一直都是采用MVC的模式，所有的业务逻辑，网络请求等都放在了View中，即Activity或者Fragment中。看了一些mvp文章，很多跨度较大，也因为自己造诣不够，还不能跟上大神门的思路。今天自己初次尝试MVP，准备一步一步慢慢来，这是第一篇-初体验，用我们常用的熟悉的登录业务引入； 介绍MVC M：逻辑模型，V：试图模型，C：控制器， 耦合性强，不利于后期维护，适合在一些较小的项目中使用； MVPModel: 具体的数据源和数据请求，访问数据库和后台服务器等；View：负责UI，Activity，Fragment；Presenter：是View和Model的桥梁，负责接收View发来的指令，并据此调用model中的方法； 释放了View，作为View 来说只需要负责UI。耦合度降低。 引入了Presenter，会导致其越来越臃肿，同样不利于后期的维护，并且，每一个包含网络请求的View都需要对应一个或者多个Presenter。实现登录活动（Activity） 很简单，点击登录执行登录过程； DataModel首先来看Model层，一般Model层需要和数据库或者后台服务器交互，这里模拟即可。1234567891011121314151617181920212223242526package com.mypractisedemos.module.mvpdemo;/** * &lt;pre&gt; * Created by fanjiajia on 2019/3/29. * desc: */public class DataModel &#123; public void login(String userName, String Password, iCallBack&lt;ResultBean&gt; callBack) &#123; ResultBean bean; // 封装返回的bean // 登录验证 if (userName.equals(&quot;张三&quot;) &amp;&amp; Password.equals(&quot;123456&quot;)) &#123; bean = new ResultBean(&quot;200&quot;, &quot;登录成功&quot;, &quot;&quot;); callBack.callSuccess(bean); &#125;else &#123; bean = new ResultBean(&quot;110&quot;, &quot;登录失败&quot;, &quot;&quot;); callBack.callFailure(bean); &#125; &#125;&#125; 这里有个iCallback，故名思义，是结果的回调。看看他的定义；123456789101112131415161718package com.mypractisedemos.module.mvpdemo;/** * &lt;pre&gt; * Created by fanjiajia on 2019/3/29. * desc: */public interface iCallBack&lt;ResultBean&gt;&#123; void callError(ResultBean bean); void callSuccess(ResultBean bean); void callFailure(ResultBean bean); void callException(ResultBean bean);&#125; 这里有四种情况，成功，失败，异常，和错误。每一个回调都需要有个ResultBean，来看看这个回调对象的定义；12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.mypractisedemos.module.mvpdemo;/** * &lt;pre&gt; * Created by fanjiajia on 2019/3/29. * desc: 回调对象 */public class ResultBean &#123; private String code; // 状态码 private String msg; // 消息 private String data; // 数据 json格式 public String getCode() &#123; return code == null ? &quot;&quot; : code; &#125; public void setCode(String code) &#123; this.code = code; &#125; public String getMsg() &#123; return msg == null ? &quot;&quot; : msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public String getData() &#123; return data == null ? &quot;&quot; : data; &#125; public void setData(String data) &#123; this.data = data; &#125; public ResultBean(String code, String msg, String data) &#123; this.code = code; this.msg = msg; this.data = data; &#125; @Override public String toString() &#123; return &quot;ResultBean&#123;&quot; + &quot;code=&apos;&quot; + code + &apos;\&apos;&apos; + &quot;, msg=&apos;&quot; + msg + &apos;\&apos;&apos; + &quot;, data=&apos;&quot; + data + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 这个参考了之前学长封装的一个OkHttp3工具的回调对象，用在这里了。 ##### iView看了Model层，现在看看试图接口定义一个接口，如下：1234567891011121314package com.mypractisedemos.module.mvpdemo;/** * &lt;pre&gt; * Created by fanjiajia on 2019/3/29. * desc: */public interface iView &#123; void loginSuccess(String resultMsg); // 登录成功回调 void loginFailure(String failureMsg);// 登录失败回调&#125; 这里很简单，主要是登录活动的回调。 DataPresenter然后开看看Presenter，之前说了这是model和view的桥梁，当点击登录按钮之后，肯定会调用其中的相应方法。先看定义；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.mypractisedemos.module.mvpdemo;/** * &lt;pre&gt; * Created by fanjiajia on 2019/3/29. * desc: */public class DataPresenter &#123; private iView mView;// 视图View private DataModel mModel;// 数据Model public DataPresenter(iView view) &#123; // 构造 this.mView = view; this.mModel = new DataModel(); &#125; /** * 定义View会发起的动作 */ public void login(String userName, String password) &#123; mModel.login(userName, password, new iCallBack&lt;ResultBean&gt;() &#123; @Override public void callError(ResultBean resultBean) &#123; &#125; @Override public void callSuccess(ResultBean resultBean) &#123; mView.loginSuccess(resultBean.getMsg()); &#125; @Override public void callFailure(ResultBean resultBean) &#123; mView.loginFailure(resultBean.getMsg()); &#125; @Override public void callException(ResultBean resultBean) &#123; &#125; &#125;); &#125;&#125; 这里看到他有两个属性，一个是View，另一个是Model，这就是为什么他是二者的桥梁。这里面的login方法中直接调用model的登录方法，然后通过iCallBack回调。 Activity最后来看看我们之前操作比较多的View12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.mypractisedemos.module.mvpdemo;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.Toast;import com.jiajia.mypractisedemos.R;import butterknife.BindView;import butterknife.ButterKnife;public class LoginMvpActivity extends AppCompatActivity implements iView&#123; // 实现iView接口 @BindView(R.id.et_mvp_login_username) EditText et_username; // 用户名 @BindView(R.id.et_mvp_login_password) EditText et_password; // 密码 @BindView(R.id.btn_mvp_login_login) Button btn_login; // 登录按钮 private DataPresenter mPresenter; // 声明Presenter @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login_mvp); ButterKnife.bind(this); // ButterKnift框架的使用 mPresenter = new DataPresenter(this); // 绑定自己的Presenter &#125; public void login(View view) &#123; // 登录按钮的onClick事件 mPresenter.login(String.valueOf(et_username.getText()), String.valueOf(et_password.getText())); &#125; @Override public void loginSuccess(String resultMsg) &#123; Toast.makeText(this, resultMsg, Toast.LENGTH_SHORT).show(); &#125; @Override public void loginFailure(String failureMsg) &#123; Toast.makeText(this, failureMsg, Toast.LENGTH_SHORT).show(); &#125;&#125; 这里我们的activity实现iView接口，并实现相应的方法即可！ 分析最后看看我的结构，果然是小白，因为把所有的东西都放在这个包下，没有层次感，因为是第一次尝试，只关注了实现思路本身。后面再进行分类。这里没有做内存泄漏的处理，来看看为何会导致内存泄漏，在activity中我们mPresenter = new DataPresenter(this); // 绑定自己的Presenter,注意，这里的this，然后在DataPresenter中this.mView = view;,这就说明了，Presenter持有了View的引用，而View(Activity)如果被切换，导致销毁，但是Presenter持有其强引用，导致无法被GC回收，因此导致这个Activity泄漏。下一篇再谈；GitHub: MVP-初体验（一） 最后 小白拙见！此致，敬礼！]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 8悬浮窗适配]]></title>
    <url>%2F2019%2F08%2F13%2FAndroid%2Fflx2%2F</url>
    <content type="text"><![CDATA[背景 APP退出时，提示是退出还是更改账号，这个提示框是系统级别的。然而我的Android 9 会崩溃，另外一个小伙伴Android 7运行理想。报错提示permission denied for window type 2038,意思就是没有赋予权限，但是打开权限管理，也确实给了权限。 原因在新建这个Dialog时调用了mDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);然而在Android 8以后，需要做新的设置，在Android 8 API中新增了一种悬浮窗类型TYPE_APPLICATION_OVERLAY, 如果使用了SYSTEM_ALERT_WINDOW,并且尝试使用以下类型的提示窗：123456TYPE_PHONE TYPE_PRIORITY_PHONE TYPE_SYSTEM_ALERTTYPE_SYSTEM_OVERLAY TYPE_SYSTEM_ERROR TYPE_TOAST 是需要更改上面的setType函数的参数的！ 解决12345678// 设置该Dialog为系统级别的if(Build.VERSION.SDK_INT &gt;= 26) &#123; mDialog.getWindow().setType( WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY); &#125;else &#123; mDialog.getWindow().setType( WindowManager.LayoutParams.TYPE_SYSTEM_ALERT); &#125; 后话还记得去年做APP的通知时，也是因为在Android 8 之后，通道必须设定通知渠道Channel！每个版本都有不同，糟心。昨天hw面试，第二轮面试官叫我画Android framework的结构图，问我Android怎么管理包，怎么管理进程等等，我一直懵逼，看得出来，我于他而言真的只是个低级程序员，他有句话这样说的：你不懂底层，不懂原理，你写的东西只是能用，那就是为了能用而用；——虽然当时心里不是很舒服，还责怪说我一个应届生，是不是要求很过了，但是讲实话，没有去搞懂什么原理，写代码真的是为了能用而写，他还说Android是不断更新的，你不去关注，那写不出好代码，今天这个就算是一个没有写好的代码吧！虽然面试官很不屑，不过还好，目前录用排序中，说明面试没有直接挂掉， 最后 此致，敬礼]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android工程方法数超过64k，The number of method references in a .dex file cannot exceed 64K.]]></title>
    <url>%2F2019%2F08%2F13%2FAndroid%2Fflx2%2F</url>
    <content type="text"><![CDATA[最近将一个老的Eclipse项目转到Android Studio后，用gradle添加了几个依赖，项目可以make，但是一旦run就报错12Error:The number of method references in a .dex file cannot exceed 64K.Learn how to resolve this issue at https://developer.android.com/tools/building/multidex.html 原因项目的方法数超过了64k，需要进行分包处理！ Android Studio解决方案： 至于Eclipse的解决方法，似乎需要采用相应插件！ 第一步，添加依赖1implementation &apos;com.android.support:multidex:1.0.1&apos;` 第二步，添加配置，build.gradle(app) buildTypes123dexOptions &#123; preDexLibraries false &#125; 这里是需要添加到buildTypes中，注意如果app依赖其他的module，那么在相应的moudle(build.gradle)中也需要添加！ 在defaultConfig下添加1multiDexEnabled true 第三步，创建MultiDexApplication 如果你有自定义的Application自定义Application 继承 android.support.multidex.MultiDexApplication;，然后重写其attachBaseContext方法 12345678910/** * 方法超过64K，需要采用分包 * fjj 2019-3-27 * @param base */ @Override protected void attachBaseContext(Context base) &#123; super.attachBaseContext(base); MultiDex.install(this); // 初始化 &#125; 如果你自己的项目没有自定义Application，也不需要自定义时，可直接在AndroidManifest.xml的application下指定： 1android:name=&quot;android.support.multidex.MultiDexApplication;&quot; 最后 此致，敬礼！]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java判断整数溢出]]></title>
    <url>%2F2019%2F08%2F13%2Fprogramming-practise%2Fflx1%2F</url>
    <content type="text"><![CDATA[开题报告第一版写完发给老师了，熬了两周终于搞出来了，等着被怼了之后再改吧。晚上选了Leetcode一道简单的题，整数反转，就是将一个int类型的数反转。原本确实很简单，最后出现个问题有意思——整数溢出。若图片无法显示，可前往简书 溢出题目给出的要求是给出一个 32 位的有符号整数,因此可以确定是int类型，但是32位int类型的范围是[$-2^{31}, 2^{31}-1$]， -2147483648-2147483647，那么问题来了，我提交代码后，提示错误：1Exception in thread &quot;main&quot; java.lang.NumberFormatException: For input string: &quot;9646324351&quot; 意思就是无法将9646324351转为int，很明显给出的原始数字是1534236469，这是一个规范的int类型数值，然而反转后9646324351很明显超过了范围。溢出了。当时我取巧了，既然是这个异常，直接在catch后return 0，机智如我，是个很人，提交，完美通过。 判断整数溢出说到底还是需要知道怎么做判断啊，我的第一直觉是转为BigDecimal，很明显，这很方便且有效：123456789/** * 方案二：转为BigDecimal */ BigDecimal b = new BigDecimal(sb.toString()); if(b.compareTo(new BigDecimal(String.valueOf(Integer.MAX_VALUE))) &gt; 0) &#123; // 溢出了 &#125;else&#123; &#125; sb.toString()就是需要判断的字符串。 那么除了转为BigDecimal，还有什么方式呢，肯定还有啦；整数可以看作是相应位数上的数字做如下操作，比如123 0*10 + 1 = 1 1*10 + 2 = 12 12 10 + 3 = 123每次增加10倍，并加上各位数字，因此可以在`每一次sum10+digit`之前做判断。1234if(Integer.MAX_VALUE/10 &lt; sum || (Integer.MAX_VALUE/10 == sum &amp;&amp; Integer.MAX_VALUE % 10 &lt; digit)) &#123; // 说明溢出 return true; &#125; 完整判断代码如下：123456789101112131415161718192021private boolean outOfRange(String str) &#123; int length = str.length(); if(length == 0)&#123; return false; &#125; int index = 0; int sum = 0; // 记录累加结果 while(index &lt; length) &#123; int digit = str.charAt(index) - &apos;0&apos;; // 这里假定str是合法的字符串，不需要进行digit合法性判断 if(Integer.MAX_VALUE/10 &lt; sum || (Integer.MAX_VALUE/10 == sum &amp;&amp; Integer.MAX_VALUE % 10 &lt; digit)) &#123; // 说明溢出 return true; &#125; // 说明还没有溢出 sum = sum * 10 + digit; index ++; &#125; return false; &#125; 参数str是需要判断的字符串，这里没有处理符号位，如果有-直接去掉，按照Integer.MAX_VALUE做比较同样可以。同时函数也没有考虑str中含有不合法的数字字符，重点关注溢出嘛。 LeetCode整数反转最后还是贴上整数反转的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.jiajia.m5;import java.math.BigDecimal;/** * @ClassName: ReverseInteger * @Author: fanjiajia * @Date: 2019/5/17 下午8:00 * @Version: 1.0 * @Description: */public class ReverseInteger &#123; public static void main(String[] args) &#123; ReverseInteger r = new ReverseInteger(); System.out.print(r.reverse(1534236469)); &#125; public int reverse(int x) &#123; if(x == 0) &#123; return 0; &#125; char[] ch_arr = String.valueOf(x).toCharArray(); StringBuilder sb = new StringBuilder(); int end_index = ch_arr[0] == &apos;-&apos;? 1 : 0; boolean flag = ch_arr[ch_arr.length - 1] == &apos;0&apos;; // 最后一位为0 for(int i = ch_arr.length - 1; i &gt;= end_index; i--) &#123; if(flag &amp;&amp; ch_arr[i] == &apos;0&apos;) &#123; continue; &#125; flag = false; sb.append(ch_arr[i]); &#125; /** * 方案一：异常里面返回，也是够了 */// int result;// try &#123;// result = end_index == 1? -Integer.valueOf(sb.toString()) : Integer.valueOf(sb.toString());// &#125;catch(NumberFormatException e) &#123;// return 0;// &#125;// return result; /** * 方案二：转为BigDecimal */// BigDecimal b = new BigDecimal(sb.toString());// if(b.compareTo(new BigDecimal(String.valueOf(Integer.MAX_VALUE))) &gt; 0) &#123;// return 0;// &#125;else&#123;// return end_index == 1? -Integer.valueOf(sb.toString()) : Integer.valueOf(sb.toString());// &#125; /** * 方案3：做溢出判断 */ if(outOfRange(sb.toString())) &#123; return 0; &#125;else &#123; return end_index == 1? -Integer.valueOf(sb.toString()) : Integer.valueOf(sb.toString()); &#125; &#125; private boolean outOfRange(String str) &#123; int length = str.length(); if(length == 0)&#123; return false; &#125; int index = 0; int sum = 0; // 记录累加结果 while(index &lt; length) &#123; int digit = str.charAt(index) - &apos;0&apos;; // 这里假定str是合法的字符串，不需要进行digit合法性判断 if(Integer.MAX_VALUE/10 &lt; sum || (Integer.MAX_VALUE/10 == sum &amp;&amp; Integer.MAX_VALUE % 10 &lt; digit)) &#123; // 说明溢出 return true; &#125; // 说明还没有溢出 sum = sum * 10 + digit; index ++; &#125; return false; &#125;&#125; 有意思的是写了个溢出判断函数的效率还没有直接catch异常来得高！！！ 最后 研三毕业了，羡慕！！！此致，敬礼！！！]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决微信小程序要求TLS版本不低于1.2问题]]></title>
    <url>%2F2019%2F08%2F13%2Fwxxcx%2Fflx1%2F</url>
    <content type="text"><![CDATA[昨天项目服务器发生意外，其上的IIS服务无法使用，导致项目后台瘫痪，倒腾一番最终以无法修复告终，启用备用的服务器，从安装IIS环境开始，然后最后所有的东西都准备就绪，却发现微信小程序苹果设备上无法使用，而安卓设备可以正常，心累…… 环境服务器：Windows IIS。 原因ios9之后，苹果要求所有的TLS（安全传输层协议）版本不低于1.2。 检查 方法一如何查看自己服务器的TLS版本呢，windows服务器上可直接到注册表中查看1[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\ 下面如果有TLS 1.2节点，表示安装了TLSv1.2。 方法二利用SSL检测进行检测，输入你的域名或者ip，查看检测结果 解决方案 情况一：如果注册表中有TLS1.2那么启动很简单，直接点击它的Client和Server，分别将右侧的Enable设为1，记住，是设为1，注意两个都需要设为1。 情况二：如果注册表中没有TLS1.2通常Windows服务器默认没有TLS1.2，此时需要自己安装，安装很简单，复制下面代码，保存到txt文件中，修改后缀名为.reg，双击执行即可。如果有提示，则选择允许或者确定之类的就可以了。1234567891011121314151617181920Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols][HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\SSL 2.0][HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\SSL 2.0\Client]&quot;DisabledByDefault&quot;=dword:00000000&quot;Enabled&quot;=dword:00000000[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2][HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\Client]&quot;DisabledByDefault&quot;=dword:00000000&quot;Enabled&quot;=dword:00000001[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\Server]&quot;DisabledByDefault&quot;=dword:00000000&quot;Enabled&quot;=dword:00000001[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.1][HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.1\Client]&quot;DisabledByDefault&quot;=dword:00000000&quot;Enabled&quot;=dword:00000001[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.1\Server]&quot;DisabledByDefault&quot;=dword:00000000&quot;Enabled&quot;=dword:00000001 上面在新建的时候就已经赋值1了，不需要再去手动更改，如果需要关闭相应的版本，直接修改Enable值为0即可。 最后一步，重启服务器，重启服务器，重启服务器，切记，重启服务器，重启服务器，重启服务器。 然后就可以看到下图了，心情真好，小程序也通了。 最后 生命不息，使劲造吧]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程练习-盛最多水的容器]]></title>
    <url>%2F2019%2F08%2F13%2Fprogramming-practise%2Fflx1%2F</url>
    <content type="text"><![CDATA[昨晚难得忙的差不多，自己有点时间，做了道中等难度的题 若图片无法显示可前往简书 题目—LeetCode盛最多水的容器 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 输入: [1,8,6,2,5,4,8,3,7]输出: 49 以上题目描述就照搬原文了 思路 思路一：暴力法首先，这道题最容易想到的就是暴力法，即计算每两个之间的盛水量，1和之后的每一个比较，2和之后的每一个比较，n-1和n比较，即k不和k-1比较。这样结果肯定是能得到的，但是效率不言而喻，若出现在笔试题中，肯定时间等过不了。来分析一下暴力法的时间复杂度： 第一个数和后面n-1个数比较，次数为(n-1)。 第二个数和后面n-2个数比较，次数为(n-2)。 …… 第n-1个数和后面第n个数比较，次数为n-(n-1)。$O(N) = n-1 + n-2 + n-3 +,……,+n-(n-1) = (n^2-n)/2$，（还去查了一下等差数列求和，手动捂脸）因此时间复杂度为$O(N^2)$ 思路二：双指针法通常在涉及到数组遍历时，能在一次遍历找到结果，是最好的结局，题目需要的是两个下标的数字去求解结果，因此想到双指针的方案，从左到右i，和从右到左j。那么问题就在于如何移动下标？其实很容易，当然是移动下标处值较小的下标。来分析一下时间复杂度： 无论是左下标移动还是右下标移动，最后都只会遍历一遍数组，因此时间复杂度为$O(N)$ 实现（java） 思路一：暴力法 123456789101112public static int maxArea(int[] height) &#123; int maxWater = 0; for(int i = 0; i &lt; height.length -1; i++) &#123; for(int j = i+1; j &lt; height.length; j++) &#123; int higth = height[i] &lt; height[j] ? height[i] : height[j]; int tempWater = higth * (j - i); if(maxWater &lt; tempWater) maxWater = tempWater; &#125; &#125; return maxWater; &#125; 思路二：双指针法 123456789101112131415161718public static int maxArea2(int[] height) &#123; int maxWater = 0; int i = 0, j = height.length - 1; int hight = 0; int temp = 0; while(i != j) &#123; hight = height[i] &lt; height[j] ? height[i] : height[j]; temp = hight * (j - i); if(temp &gt; maxWater) maxWater = temp; if(height[i] &lt;= height[j]) &#123; i++; &#125; else &#123; j--; &#125; &#125; return maxWater; &#125; 在上面方法中，没有用到Java的Math类，主要是之前听人说，这些类的使用会使得运行时间变长。所以我为了验证，就有了下面的方法1234567891011121314public static int maxArea3(int[] height) &#123; int maxWater = 0; int i = 0, j = height.length - 1; while(i != j) &#123; maxWater = Math.max(maxWater, Math.min(height[i], height[j]) * (j - i)); if(height[i] &lt;= height[j])&#123; i++; &#125; else&#123; j--; &#125; &#125; return maxWater; &#125; 那么暴力法究竟效率有多低，使用Math类的处理，又和没用Math类的处理方法有何区别？直接上图。对比发现： 暴力法确实效率低。 使用Math类并不会使得效率有多大的改变，所以以后可以使用这些数学类，减少代码。 最后 此致，敬礼]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android数据绑定DataBinding（二）入门篇]]></title>
    <url>%2F2019%2F07%2F07%2FAndroid%2Fflx1%2F</url>
    <content type="text"><![CDATA[前言 之前写了Android数据绑定DataBinding（一）入门篇,很简单的记录了如何使用DataBinding，其初衷是想要代码中的数据发生改变，不需要繁琐的setText等操作，在最后说到了只需要将POJO继承一个BaseObservable即可，其实这只是冰山一角啦！！！ 本文若有出入，请指正——来自小渣渣的颤抖本文接着上一篇的内容，记录一下数据对象和事件处理 数据对象(Data Object)其实继承BaseObservable的javBean叫做数据对象，官网介绍如下：12Any plain old Java object (POJO) may be used for data binding, but modifying a POJO will not cause the UI to update. The real power of data binding can be used by giving your data objects the ability to notify when data changes. There are three different data change notification mechanisms, Observable objects, observable fields, and observable collections.When one of these observable data object is bound to the UI and a property of the data object changes, the UI will be updated automatically. 大意是：12任何普通的Java对象（PO​​JO）都可以用于数据绑定，但修改POJO不会导致UI更新。当数据改变的时候,您的数据对象能够发出通知，这才是数据绑定的威力。有三种不同的数据更改通知机制： Observable对象，observable字段, 和observable集合.当这些observable数据对象之一被绑定到UI并且数据对象的属性改变时，UI将被自动更新。 Observable对象这个就是我在Android数据绑定DataBinding（一）入门篇中最后介绍的那样，将我们的Bean继承 BaseObservable，这里再贴一下code;12345678910111213141516171819202122232425262728293031public class User extends BaseObservable&#123; private String userName; private int age; public User(String userName, int age) &#123; this.userName = userName; this.age = age; &#125; @Bindable public String getUserName() &#123; return userName == null ? &quot;&quot; : userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; notifyPropertyChanged(BR.userName); &#125; @Bindable public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; notifyPropertyChanged(BR.age); &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;userName=&apos;&quot; + userName + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125; 可以看到在setter方法中调用了notifyPropertyChanged(BR.age);文档中这样介绍道：The Observable interface has a mechanism to add and remove listeners, but notifying is up to the developer.也就是说，这种机制允许开发者自己对被监听的字段进行添加和删除，我的理解就是(看你自己想绑定那些字段)。 ObservableFields相比于上一种方式，使用ObservableFields则可以减少许多的工作量，因为我们可以许多提供的类型，文档介绍如下：ObservableField and its siblings ObservableBoolean, ObservableByte, ObservableChar, ObservableShort, ObservableInt, ObservableLong, ObservableFloat, ObservableDouble, and ObservableParcelable.示例：12345678910public class People &#123; public ObservableField&lt;String&gt; name = new ObservableField&lt;&gt;(); public ObservableInt age = new ObservableInt(); public ObservableList&lt;String&gt; list = new ObservableArrayList&lt;&gt;(); public People(String name, int age, ArrayList&lt;String&gt; list) &#123; this.name = new ObservableField&lt;&gt;(name); this.age = new ObservableInt(age); this.list = (ObservableArrayList)list; &#125;&#125; 这样就不需要我们自己在getter上设置@binding，在setter中设置notifyPropertyChanged(int)了。 Observable 集合官方列举了这样两个例子,ObservableArrayMap和ObservableArrayList，其中对ObservableArrayMap的介绍是key是String这样的类型时，是非常有用的，示例如下：1234ObservableArrayMap&lt;String, Object&gt; user = new ObservableArrayMap&lt;&gt;();user.put(&quot;firstName&quot;, &quot;Google&quot;);user.put(&quot;lastName&quot;, &quot;Inc.&quot;);user.put(&quot;age&quot;, 17); 在layout中12345678910111213&lt;data&gt; &lt;import type=&quot;android.databinding.ObservableMap&quot;/&gt; &lt;variable name=&quot;user&quot; type=&quot;ObservableMap&lt;String, Object&gt;&quot;/&gt;&lt;/data&gt;…&lt;TextView android:text=&apos;@&#123;user[&quot;lastName&quot;]&#125;&apos; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt;&lt;TextView android:text=&apos;@&#123;String.valueOf(1 + (Integer)user[&quot;age&quot;])&#125;&apos; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; 我的理解就是一些集合类型的封装使用。 事件处理(Event Handling)之前对某个View设置某种监听事件是通过setXXXX，在数据绑定中是如何实现的呢，有两种方式 方法引用(Method References) 监听器绑定(Listener Bindings)方法引用(Method References)其实这种方法在之前也使用过，较多的是button的onClick事件，通常是直接在布局中写上相应Activity中的方法即可，其实这就是方法引用，学习官网的例子，我写的demo示例如下： 布局文件中 12345678910&lt;variable name=&quot;presenter&quot; type=&quot;com.jiajia.mypractisedemos.module.jetpack.JetpackActivity.Presenter&quot;/&gt;...... &lt;Button android:text=&quot;click&quot; android:textAllCaps=&quot;false&quot; android:onClick=&quot;@&#123;presenter.onClick&#125;&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; Activity中 123456public class Presenter &#123; public void onClick(View view) &#123; people.name.set(&quot;啊啊啊啊啊&quot;); Toast.makeText(JetpackActivity.this, &quot;点击了Button&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125; 这里注意必须给定参数View view，即需要符合事件监听的写法。 监听器绑定(Listener Bindings)这个说真的，没特别理解，简单整理一下，英文文档说:在方法引用中，方法的参数必须与事件监听器的参数匹配。在监听器绑定中，只有你的返回值必须与监听器的期望返回值相匹配（除非它预期为void），例如：123public class Presenter &#123; public void onSaveClick(Task task)&#123;&#125;&#125; 然后，您可以将click事件绑定到您的类，如下所示：1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;data&gt; &lt;variable name=&quot;task&quot; type=&quot;com.android.example.Task&quot; /&gt; &lt;variable name=&quot;presenter&quot; type=&quot;com.android.example.Presenter&quot; /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:onClick=&quot;@&#123;() -&gt; presenter.onSaveClick(task)&#125;&quot; /&gt; &lt;/LinearLayout&gt; &lt;/layout&gt; 注意这里没有传入view参数，可能这就是与方法引用不同之处，当然也可以传啦，android:onClick=&quot;@{(view) -&gt; presenter.onSaveClick(task)}&quot;，还有好几种，也不知道什么情况下用，也不懂，不写了，以后用到再说。我觉得就方法引用的方式用得比较多，比较太low了平时写的代码。 方法引用和监听器绑定的主要区别在于实际的监听器实现是在绑定数据时创建的，而不是在事件触发时创建的。如果您喜欢在事件发生时计算表达式，则应该使用监听器绑定。 最后下午6点了，好饿，去食堂吃麻辣烫了！ 此致，敬礼]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android数据绑定DataBinding（一）入门篇]]></title>
    <url>%2F2019%2F07%2F06%2FAndroid%2Fflx1%2F</url>
    <content type="text"><![CDATA[早上看到了一篇推文“还在使用繁琐的findViewById，跟着尝试了一下DataBinding，之前使用ButteKnife就已经干掉了findViewById。因为写过微信小程序，那种在js中数据源改变，UI中的数据跟着改变，真的很爽。本文个人拙见，如果有误人子弟处，请提出，感激——来自小渣渣的颤抖 配置关于DataBinding的介绍不说了，我也没搞懂，先会用。在app的build.gradle中添加如下内容，表示支持数据绑定，（个人理解）因为使用数据绑定会通过布局文件自动生成许多的东西，见后面。123456android &#123; ..... dataBinding &#123; enabled = true; &#125;&#125; 布局使用新建一个activity，在其layout中使用如下12345678910111213141516171819202122232425&lt;layout&gt; &lt;data&gt; &lt;variable name=&quot;user&quot; type=&quot;com.jiajia.mypractisedemos.module.jetpack.User&quot;/&gt; &lt;/data&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;com.jiajia.mypractisedemos.module.jetpack.JetpackActivity&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.userName&#125;&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:text=&quot;更换User&quot; android:layout_height=&quot;wrap_content&quot; /&gt; ...... &lt;/LinearLayout&gt;&lt;/layout&gt; 这里布局的根节点不是平时使用的几大布局了，而是layout，看其他的文章说使用layout会自动生成绑定类（见后面）。在data标签下新建变量variable，设置name属性和type属性，name随便取，在本xml中使用，这里的type可以是我们平时使用的基本数据类型，也可以是自己封装的类等，显而易见就是布局文件需要使用的数据，这里定义了一个User类，多么通用的栗子啊。User类就是个简单的Model啦12345678910111213141516171819202122public class User&#123; private String userName; private int age; public User(String userName, int age) &#123; this.userName = userName; this.age = age; &#125; public String getUserName() &#123; return userName == null ? &quot;&quot; : userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; 再回到xml中，这里复制一下TextView节点，便于浏览1234&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@&#123;user.userName&#125;&quot;/&gt; android.text = &quot;@{user.userName}&quot;，使用@{}即可取user中的值，这个user就是顶部定义的绑点数据啦，到这里，我开始思考，这个user是不是到时候我在我的Activity中进行绑点操作就可以直接显示到我的界面了啊。bingo，废话，不然叫数据绑定啊。 Activity中绑定有了布局文件，有了需要绑定的数据，怎么将其进行绑定呢，说白了，我界面需要使用user这个对象，我总得初始化吧。很简单了，在Activity中,创建两个全局变量12ActivityJetpackBinding binding;User user; 这里user没什么好说了，那个ActivityJetpackBinding是什么鬼，说一下我的Activity名字叫JetpackActivity，so，这个类就是前面我说的自动生成的啦，怎么实例化呢。1binding = DataBindingUtil.setContentView(this,R.layout.activity_jetpack); 使用DataBindingUtil就可以了，咦，这个setContentView好熟悉，一般onCreate中都有这个，一想到绑定，难道这句话会把之前的那个setContentView也干掉了，我小心翼翼的去掉之前的setContentView，果然可以运行，那怎么干掉的呢（其实不用看，我只是好奇怎么干掉的，所以看看源码，之前面试腾讯的时候，面试官叫我多看看源码，哎）， 点进去看到123public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId) &#123; return setContentView(activity, layoutId, sDefaultComponent); &#125; 再点return后面的setContentView1234567public static &lt;T extends ViewDataBinding&gt; T setContentView(Activity activity, int layoutId, DataBindingComponent bindingComponent) &#123; activity.setContentView(layoutId); View decorView = activity.getWindow().getDecorView(); ViewGroup contentView = (ViewGroup) decorView.findViewById(android.R.id.content); return bindToAddedViews(bindingComponent, contentView, 0, layoutId); &#125; ok，熟悉的activity.setContentView(layoutId);说明确实干掉了。 得到了binding对象，新建一个User，怎么将新建的User和binding联系起来呢原来binding有setter和getter啦binding.setUser(user);就这样，运行时，TextView的值有了，全程没有使用之前的setTex(),完整一点的onCreate代码1234// setContentView(R.layout.activity_jetpack); binding = DataBindingUtil.setContentView(this,R.layout.activity_jetpack); user = new User(&quot;家佳&quot;,25); binding.setUser(user); 到这里，基本的绑定就实现了，算是入门了吧，来看看和之前的区别，布局文件中没有id，activity中没有绑定id，没有setText，确实看起来少了许多。But….. 这肯定不是我要的效果啊，我要的是改变user的值，界面跟着改变，不用去setText所以我开始思考 思考如果我改变User的值，界面会跟着变吗？其实肯定会的，只是我还不知道怎么用，我的想法很单纯，很简单，搞个Button，点击需改全局User的值，界面跟着变，ok，我写了，然而打了自己的脸，我怎么这么可爱，too young 以为 很simple。那么怎么才能实现这个效果呢。 动态绑定原来需要在User这个类上下功夫数据绑定提供了基类BaseObservable，需要继承它，修改后的User如下1234567891011121314151617181920212223242526public class User extends BaseObservable&#123; private String userName; private int age; public User(String userName, int age) &#123; this.userName = userName; this.age = age; &#125; @Bindable public String getUserName() &#123; return userName == null ? &quot;&quot; : userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; notifyPropertyChanged(BR.userName); &#125; @Bindable public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; notifyPropertyChanged(BR.age); &#125;&#125; 在getter上面加@Bindable，在setter函数中加notifyPropertyChanged,好像Adapter啊，一看这个实现应该是观察者模式啦。这里notifyPropertyChanged需要一个int参数，查看一番，据说类似R.java中的id一样，不懂，看别人用的BR，直接用BR即可，关于BR是啥，还不知道。更改了User类之后，在之前的button中通过user.setUsername()，完美实现了布局中数据的改变。 最后数据绑定还有很多东西，比如动态绑定，不需要这么麻烦，比如Button的onClick事件也可以绑定，下篇再说把。 此致，敬礼]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序wx.request的简单封装]]></title>
    <url>%2F2019%2F07%2F06%2Fwxxcx%2Fflx1%2F</url>
    <content type="text"><![CDATA[前言 之前写小程序，每次请求后台时都直接调用原生的API，wx.request，每次都要写url，data，回调函数等，正好前段时间，小程序项目需要添加新内容，趁此机会，做一个封装的请求工具，比较简单。 本文若有出入，请指正——来自小渣渣的颤抖 原生的API首先看看原生的api，wx.request需要写如下东西：123456789101112131415wx.request(&#123; url: &apos;&apos;, // url地址 // 参数 data:&#123; &#125;, method:&apos;&apos;, // post || get success: res=&gt; &#123; // 请求成功回调函数，res为回调参数 &#125;, fail:res=&gt; &#123; // 请求失败回调函数，res为回调参数 &#125; &#125;) 每次网络请求都需要写这些内容，其实在实际项目中，大多情况下url都是由基地址+请求模块构成，比如https://woshigecainiao.com/myservice/login， 这里基地址为：https://woshigecainiao.com/myservice/， 模块为/login。基地址一般都不会变，method通常也是约定好的，一律post或者get等，fail回调一般都会统一处理，所以不同的是参数data，和请求成功后的处理。 实现在util目录下新建NetAPI.js1234567891011121314151617181920212223242526272829303132333435363738const config = require (&quot;../config.js&quot;) // 域名配置等const request = (url, data, showLoading) =&gt; &#123; let _url = config.baseurl + url; return new Promise((resolve, reject)=&gt; &#123; // 由调用者控制是否需要显示加载对话框 if (showLoading)&#123; wx.showLoading(&#123; title: &apos;加载中&apos;, mask: true &#125;) &#125; wx.request(&#123; url: _url, method: &apos;post&apos;, data: data, success(res) &#123; // console.error(res) wx.hideLoading(); resolve(res.data) &#125;, fail(err) &#123; console.error(&apos;网络请求失败&apos;,err) wx.hideLoading(); wx.showModal(&#123; title: &apos;提示&apos;, content: &apos;网络请求失败&apos;, showCancel: false &#125;) &#125; &#125;) &#125;)&#125;module.exports = &#123; // 此处调用可直接使用NetAPI.VehicleResManager(data).then(...)，第二个参数showLoading采用缺省，即默认使用加载，调用给false，即可屏蔽默认的加载框，js不支持方法重载，也是没办法 VehicleResManager: (data, showLoading) =&gt; &#123; return request(config.CLYYQuery, data, showLoading == undefined ? true : showLoading) &#125;&#125; 这里我导入了config.js文件，其中配置了后台服务器的ip和后台请求基地址和请求模块地址等，这样便于统一管理，只需要在config中配置，NetAPI中调用即可，NetAPI中不关心具体的url。1const request = (url, data, showLoading) =&gt; &#123;...&#125; url：后台不同模块的入口，比如login等这样的模块 data：请求所需要的参数data showLoading：发起网络请求是否需要显示加载对话框的控制开关以我这里的例子为例，我最后暴露除了VehicleResManager,即车辆预约管理模块，所对应了后台模块地址卸载config中config.CLYYQuery，这样，在page的js中只需要简单的调用暴露的相关入口即可。调用在某个page中首先导入该工具1const NetAPI = require(&apos;../../utils/NetAPI.js&apos;) 调用处：1NetAPI.VehicleResManager(data, that.data.curPage == 0).then(res =&gt; &#123;...&#125; res即为请求返回数据，不包含网络状态等，因为在工具中resolve(res.data)中直接返回的是返回体的data部分。 这里关于Promise就不说了 最后 此致，敬礼]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET进行请求转发]]></title>
    <url>%2F2019%2F07%2F04%2FCplusplus%2Fflx1%2F</url>
    <content type="text"><![CDATA[前言 前两天将网站的部分功能在小程序上实现，网站的后台是http，没有配置域名和安全证书，小程序的线上版本是无法访问的，因此需要从配有域名和安全证书的站点进行转发。即小程序请求A，A转发请求到B，B获取数据给A，A再回传给小程序。 本文若有出入，请指正——来自渣渣的颤抖 ASP.Net接收前台发送的请求都是从一个一般处理程序ashx开始的1public void ProcessRequest(HttpContext context) context即为请求的上下文，包括了请求的参数等等信息。 实现一开始，我自信的以为实现这样的转发是特别easy的一件事，因为在我漫无边际的知识储备中，一个熟悉而又陌生但却非常有好感的字眼——redirect浮现在我眼前，完美。然而，啪啪啪打脸发生在我redirect之后，B获取参数抛出一个非常性感的异常，未将对象添加到引用的实例，即空指针异常。仔细一想，mb，redirect后参数没有带过去啊，但是说明转发成功了，开森，然而，我真的太年轻啊。百度，没有人说redirect可以带参数，（所以我也不知道到底可不可以），凉凉没办法最后只能新建一个request，自己封装请求。12345678910111213141516171819202122232425262728293031323334 try &#123; string host_reservation = &quot;&quot;; // 本地车辆预约网站后台 string host_reservation = &quot;&quot;; // 实验楼车辆预约网站后台 string host_reservation = &quot;&quot;; // 现场车辆预约网站后台 string baseurl_reservation = &quot;http://&quot; + host_reservation + &quot;/Handler/WebSpace/XX/XX.ashx&quot;; HttpWebRequest req = (HttpWebRequest)HttpWebRequest.Create(baseurl_reservation); Encoding encoding = Encoding.UTF8; string param = HttpUtil.GetPostParams(context); Utility.LogWrite.WriteTestLog(&quot;paras&quot;, param); byte[] bs = Encoding.UTF8.GetBytes(param); string responseData = String.Empty; req.Method = &quot;POST&quot;; req.ContentType = &quot;application/json&quot;; // &apos;application/json&apos; &quot;application/x-www-form-urlencoded&quot; req.ContentLength = bs.Length; using (Stream reqStream = req.GetRequestStream()) &#123; reqStream.Write(bs, 0, bs.Length); reqStream.Close(); &#125; using (HttpWebResponse response = (HttpWebResponse)req.GetResponse()) &#123; using (StreamReader reader = new StreamReader(response.GetResponseStream(), encoding)) &#123; responseData = reader.ReadToEnd().ToString(); &#125; context.Response.Write(responseData); &#125;&#125;catch (Exception e)&#123; LogWrite.WriteSysLog(&quot;Reservation_Location&quot;, e); context.Response.Write(BackDataUtil.BackResult(110, &quot;异常了&quot;, &quot;0&quot;));&#125; 其实也不复杂，就是再发起一次请求，这里注意，req.ContentType，我已开始用的application/x-www-form-urlencoded，发送到B的中文会乱码 最后完美实现，然而没高兴多会儿，直接抛弃了我这么辛苦实现的，因为这玩意实在是太慢了，本来B上的处理，数据量就较大，再加上转发，慢得我可以边等他加载，边玩王者，，，，，为什么说这玩意慢呢，因为现在把B上的内容copy到A上了，不转发了，确实快了，在下觉得是不是因为这里的流处理，流这个东西，谁知道呢！ 最后 此致，敬礼]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序设置滚动条]]></title>
    <url>%2F2019%2F07%2F02%2Fwxxcx%2Fflx1%2F</url>
    <content type="text"><![CDATA[前言 又很久没有写东西了，上周开始将一个APP和一个网站的内容整合到微信小程序中，到这会儿终于搞得快结束了，才发现为啥我的小程序滚动视图没有滚动条，这是闹哪样，没有滚动条的滚动是没有灵魂的。 本文若有出入，请指正——来自小渣渣的颤抖 原因原来在app.wxss中定义了如下的内容【不知道是不是新建项目自动生成的，这里也就提供了隐藏滚动条的思路啦】12345::-webkit-scrollbar &#123; width: 0px; height: 0px; color:#transparent;&#125; what, 宽高为0，而且还是透明的，难怪，好吧，修改宽高4px，color设置为green，以为可以了，呵呵，太年轻。scroll-viwe依然没有滚动条，以为是布局原因，导致滚动条消失在界面外，我将宽高设为20px，想想也是搞笑，设这么宽，但是，正是这种傻劲，再运行，发现右边宽出了好多，然而还是没有滚动条，懂了，肯定还有其他设置，果不其然…… 解决一通捣腾，原来，除了设置::-webkit-scrollbar，还需要设置::-webkit-scrollbar-track，这是设置滚动的轨道，::-webkit-scrollbar-thumb，这是设置滚动条的。所以完整的设置如下(在app.wxss中，这样所有的scroll-view都有了，如果需要单独设置样式，可在单独page的wxss中设置)123456789101112131415161718192021::-webkit-scrollbar &#123; width: 4px; height: 4px; color:#ffffff;&#125;/*定义滚动条轨道 内阴影+圆角*/::-webkit-scrollbar-track &#123; -webkit-box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3); box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.1); border-radius: 10px; background-color:#FFFFFF;&#125;/*定义滑块 内阴影+圆角*/::-webkit-scrollbar-thumb &#123; border-radius: 10px; -webkit-box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3); box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.1); background-color:#39b54a;&#125; 好了，看看效果 最后 生命不息，使劲造]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程练习-字母异位词分组]]></title>
    <url>%2F2019%2F05%2F11%2Fprogramming-practise%2Fflx1%2F</url>
    <content type="text"><![CDATA[又很久没有做做题了，哎…… 题目-LeetCode字母异位词分组 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],输出:[ [“ate”,”eat”,”tea”], [“nat”,”tan”], [“bat”]] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 分析这个题难度定位为中等，个人感觉难度中等有点夸张了。只要把题目和示例看一下就应该知道思路了。 1. 归入一组的字符串组成字母相同，只是顺序不一样而已，因此进行一次排序就好了，相同组的字符串都是同一个字符串形式了，比如示例中的第一组，排序后为`aet`。 2. 最后用一个map做存储结构，因为HashMap的key是不重复的，用排好序的字符串作为key，value当然是list啦。 思路： 实现（java）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;/** * @ClassName: GroupAnagrams * @Author: fanjiajia * @Date: 2019/5/11 下午3:09 * @Version: 1.0 * @Description: 给定一个字符串数组，将字母异位词组合在一起。 * 字母异位词指字母相同，但排列不同的字符串。 */public class GroupAnagrams &#123; public static void main(String[] args) &#123; GroupAnagrams g = new GroupAnagrams(); String[] strs = &#123;&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;&#125;; g.groupAnagrams(strs); &#125; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; /** * 1 保存原始值, 此处不能直接:tempStrs = strs(java参数传递问题) */ String[] tempStrs = new String[strs.length]; for(int k = 0; k &lt; strs.length; k++) &#123; tempStrs[k] = strs[k]; &#125; /** * 2 原始的字符串数组中每个字符串按字母排序 */ for(int i = 0; i &lt; strs.length; i++)&#123; char[] arr = strs[i].toCharArray(); // 转为字符数组 Arrays.sort(arr); strs[i] = String.valueOf(arr); &#125; /** * 3 整理判断 */ HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for(int j = 0; j &lt; tempStrs.length; j++) &#123; if(map.containsKey(strs[j])) &#123; map.get(strs[j]).add(tempStrs[j]); &#125;else &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(tempStrs[j]); map.put(strs[j], list); &#125; &#125; // 取出map的值// System.out.print(new ArrayList(map.values())); return new ArrayList(map.values()); &#125;&#125; 这里排序没有重写方法，直接使用Arrays.sort(arr);即可。 需要对原始的字符串数组进行备份，因为排序会改变原有的字符串数组中的元素。备份时，不能直接使用=进行复制，java参数传递是值传递，这里传递的是strs数组的地址，那么=号直接操作的结果是tempStrs同样指向了原始数组strs，排序一样被改变，这也是浅复制和深复制的问题。最后 此致，敬礼]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程练习-判断是否为易混淆数]]></title>
    <url>%2F2019%2F04%2F27%2Fprogramming-practise%2Fflx1%2F</url>
    <content type="text"><![CDATA[题目来源：LeetCode 给定一个数字 N，当它满足以下条件的时候返回 true：把原数字旋转180°以后得到新的数字。如 0, 1, 6, 8, 9 旋转 180° 以后，得到了新的数字 0, 1, 9, 8, 6 。2, 3, 4, 5, 7 旋转 180° 后,得到的不是数字。易混淆数字 (confusing number) 就是一个数字旋转180°以后，得到和原来不同的数字，且新数字的每一位都是有效的。 示例 1： 6 -&gt; 9输入：6输出：true解释： 把 6 旋转 180° 以后得到 9，9 是有效数字且 9!=6 。 示例 2： 89 -&gt; 68输入：89输出：true解释: 把 89 旋转 180° 以后得到 68，86 是有效数字且 86!=89 。 示例 3： 11 -&gt; 11输入：11输出：false解释：把 11 旋转 180° 以后得到 11，11 是有效数字但是值保持不变，所以 11 不是易混淆数字。 提示： 0 &lt;= N &lt;= 10^9 可以忽略掉旋转后得到的前导零，例如，如果我们旋转后得到 0008 那么该数字就是8。 分析 题目中已经明确提示，哪些数字（0-9）旋转后是有效的，因此第一步就需要判断给定的整数中是否包含旋转无效的数字； 最后的提示很重要，如果旋转后前面连续的0位，可以忽略，既然这样，只要旋转后第一位是0的，都不会和原整数相等。 旋转不单单是单个数字的旋转，最后整个数字也会前后倒置。 将整数转为字符串要方便许多，因为可以直接取相应位。 流程图： 实现（java）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.jiajia.m4;import java.util.HashMap;/** * @ClassName: ConfusingNumber * @Author: fanjiajia * @Date: 2019/4/27 上午10:06 * @Version: 1.0 * @Description: */public class ConfusingNumber &#123; public static void main(String[] args) &#123; ConfusingNumber c = new ConfusingNumber(); int test_num = 89; System.out.println(c.confusingNumber(test_num)); &#125; public boolean confusingNumber(int N) &#123; String str_N = String.valueOf(N); // 将数字转为字符串，方便处理 // 定义相应数字字符旋转后的字符映射 HashMap&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;() &#123; &#123; put(&apos;0&apos;, &apos;0&apos;); put(&apos;1&apos;, &apos;1&apos;); put(&apos;6&apos;, &apos;9&apos;); put(&apos;8&apos;, &apos;8&apos;); put(&apos;9&apos;, &apos;6&apos;); &#125; &#125;; /** * 先判断其中是否包含不满足旋转的字符 */ for(int i = 0; i &lt; str_N.length(); i++) &#123; if(!map.containsKey(str_N.charAt(i)))&#123; // 通过map的key进行判断 return false; &#125; &#125; /** * 接下来判断旋转后的数字是否等于原来的数字 */ if((str_N.charAt(str_N.length() - 1) == &apos;0&apos;) &amp;&amp; str_N.length() &gt; 1) &#123; // 如果最后一位是0 ，则说明旋转后的数字一定不等于原来的数字 return true; &#125; char[] arr = new char[str_N.length()]; // 旋转后的字符串 for(int i = str_N.length() - 1; i &gt;= 0; i--) &#123; arr[(str_N.length() -1) - i] = map.get(str_N.charAt(i)); &#125; String temp = String.valueOf(arr); if(temp.equals(str_N)) &#123; return false; &#125; return true; &#125;&#125; 最后 可以直接利用map的key做contains判断，之前还单独声明了一个list做contains判断，哎，真的菜； 此致，敬礼]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程练习-寻找最长回文串]]></title>
    <url>%2F2019%2F04%2F25%2Fprogramming-practise%2Fflx1%2F</url>
    <content type="text"><![CDATA[又是很久没有练习了，前段时间的字节跳动和阿里笔试题，真的是惨绝人寰，这道题，难度定义为中等，又做了一个小时，哎，为秋招深深的担忧啊！ 题目来源LeetCode 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad” 输出: “bab” 注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 分析从它的示例可以看出，回文分为两种，奇数长度的回文，偶数长度的回文！ 思路 奇回文：以正中间处的字符为中心，向两边展开。 偶回文：以正中间处的两个字符为中心，向两边展开。 实现（java）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.jiajia.m4;/** * @ClassName: LongestPalindromic * @Author: fanjiajia * @Date: 2019/4/25 下午7:32 * @Version: 1.0 * @Description: 求字符串最长回文串 */public class LongestPalindromic &#123; public static void main(String[] args) &#123; LongestPalindromic palindromic = new LongestPalindromic(); String s = &quot;aaabaaaa&quot;; System.out.println(palindromic.longestPalindrome(s)); &#125; public String longestPalindrome(String s) &#123; String res_str = &quot;&quot;; // 结果串 if(s == null || s.length() == 0) &#123; return res_str; &#125;else if(s.length() == 1) &#123; // 长度为1的串 res_str = s; &#125;else &#123; // 长度超过1 /** * 循环遍历每一个字符，向两端伸展，这种是奇数回文串 */ int low, hight; for(int i = 0; i &lt; s.length(); i++) &#123; low = hight = i; while((--low) &gt;= 0 &amp;&amp; (++hight) &lt; s.length() &amp;&amp; s.charAt(low) == s.charAt(hight)) &#123; &#125; if(low &gt;= 0 &amp;&amp; hight &lt; s.length()) &#123; // 说明low处的字符和hight处的字符不相等 if(res_str.length() &lt; (((--hight) - (++low)) + 1)) &#123; res_str = s.substring(low, hight + 1); &#125; &#125;else if(low &lt; 0) &#123; // low率先出界 if(res_str.length() &lt; ((hight) - (++low)) + 1) &#123; // low和hight相邻，需要判断二者是否相等 res_str = s.substring(low, hight + 1); &#125; &#125;else &#123; // hight超出边界 if(res_str.length() &lt; ((--hight) - (++low)) + 1) &#123; // low和hight相邻，需要判断二者是否相等 res_str = s.substring(low, hight + 1); &#125; &#125; /** * 循环遍历每一个字符，向两端伸展，偶数回文的查找 */ low = i; hight = i+1; if(low == s.length() -1) &#123; break; &#125; if(s.charAt(low) != s.charAt(hight)) &#123; // 正中间两个字符一定是相等的 continue; &#125; while((--low) &gt;= 0 &amp;&amp; (++hight) &lt; s.length() &amp;&amp; s.charAt(low) == s.charAt(hight)) &#123; &#125; if(low &gt;= 0 &amp;&amp; hight &lt; s.length()) &#123; // 说明low处的字符和hight处的字符不相等 if(res_str.length() &lt; (((--hight) - (++low)) + 1)) &#123; if(hight - low != 1 || (hight - low == 1 &amp;&amp; s.charAt(low) == s.charAt(hight)))&#123; res_str = s.substring(low, hight + 1); &#125; &#125; &#125;else if(low &lt; 0) &#123; // low率先出界 if(res_str.length() &lt; ((hight) - (++low)) + 1) &#123; if(hight - low != 1 || (hight - low == 1 &amp;&amp; s.charAt(low) == s.charAt(hight)))&#123; res_str = s.substring(low, hight + 1); &#125; &#125; &#125;else &#123; // hight超出边界 if(res_str.length() &lt; ((--hight) - (++low)) + 1) &#123; if(hight - low != 1 || (hight - low == 1 &amp;&amp; s.charAt(low) == s.charAt(hight)))&#123; res_str = s.substring(low, hight + 1); &#125; &#125; &#125; &#125; &#125; return res_str; &#125;&#125; 一定要注意在i定位到字符串最后一位时，也即此时不可能再出现偶数回文了，需要break，否则会存在案例比如ac导致数组下标越界错误！ 偶回文时，正中间两个一定是相等的。 while循环中，如果前面返回false，那么后面的判断将不会执行，所以–low和hight++并不是都会执行。 substring(beginIndex, endIndex)并不包含endIndex处的字符（多么基础的领悟）！最后 此致，敬礼]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程练习:字符串展开]]></title>
    <url>%2F2019%2F04%2F11%2Fprogramming-practise%2Fflx1%2F</url>
    <content type="text"><![CDATA[题目来源：华为实习笔试题 给定一个字符串，其中含有括号(大括号，中括号，小括号)，括号可以嵌套，且保证括号是配对的，括号前面会有一个数字，要求对字符串进行展开，不带括号，且括号中的内容需要连续出现括号前面数字规定的次数，并且倒序输出；示例abc3{A}，输出结果: AAAcba 分析 (当时内心活动[废话])这是三道题中的第二题，当我看到倒序输出时，毫无疑问这需要用到栈，回想起了之前本科学到的中缀表达式求值。好吧看似一切很顺利，突然发现，括号嵌套，mb，我居然在这个地方陷进去了，所以做了第三题，示例通过率只有45%，再回来做这一题，一直想着两个栈外加一个队列去实现，好吧，恶性循环。最后居然没做出来，更可恨的是，提交了之后，猛然发现自己好蠢啊！ 其实两个栈就可以了，一个用作最后的结果栈tack_res,一个用作临时栈stack_temp，用来进行括号中间串的临时存储。具体步骤： 循环遍历原始串，如果当前字符不是右括号}、]、)，将其push到结果栈stack_res中，否则转2； 将结果栈中的字符依次pop，判断是否是左括号{、[、(，如果是则转3，否者将字符push到临时栈stack_temp中。 取结果栈stack_res栈顶元素，这个字符一定是括号前面的数字字符n，表示需要将临时栈stack_temp中的内容重复n次。 将临时栈中的字符拼凑成字符，并借助StringBuilder拼凑n次。 将拼凑出的字符串依次将字符push到结果栈stack_res中，回到1。*流程实现（java）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package sx20190410;import java.util.*;/** * @ClassName: StringExtendWithKuoHao * @Author: fanjiajia * @Date: 2019/4/10 下午8:29 * @Version: 1.0 * @Description: */public class StringExtendWithKuoHao &#123; private static Scanner scanner = new Scanner(System.in); public static void main(String[] args) &#123; List&lt;Character&gt; list = new LinkedList&lt;Character&gt;()&#123; &#123; add(&apos;&#123;&apos;); add(&apos;[&apos;); add(&apos;(&apos;); add(&apos;)&apos;); add(&apos;]&apos;); add(&apos;&#125;&apos;); &#125; &#125;; List&lt;Character&gt; list_left = new LinkedList&lt;Character&gt;()&#123; &#123; add(&apos;&#123;&apos;); add(&apos;[&apos;); add(&apos;(&apos;); &#125; &#125;; List&lt;Character&gt; list_right = new LinkedList&lt;Character&gt;()&#123; &#123; add(&apos;)&apos;); add(&apos;]&apos;); add(&apos;&#125;&apos;); &#125; &#125;; while (scanner.hasNext()) &#123; String str = scanner.next(); // 原始字符串 Stack&lt;Character&gt; stack_res = new Stack&lt;&gt;(); Stack&lt;Character&gt; stack_temp = new Stack&lt;&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; if (!list_right.contains(str.charAt(i))) &#123; // 不是右边的 stack_res.push(str.charAt(i)); &#125;else &#123; // 是右边的，消解 Character character; while (!list_left.contains((character = stack_res.pop()))) &#123; // 弹出的不是左边括号也就是字符，加入临时栈 stack_temp.push(character); &#125; // character是左边括号 int n = Integer.valueOf(String.valueOf(stack_res.pop())); String temp = &quot;&quot;; StringBuilder sb = new StringBuilder(); while (stack_temp.size() &gt; 0) &#123; temp += stack_temp.pop(); &#125; for (int j = 0; j &lt; n; j++) &#123; sb.append(temp); &#125; temp = sb.toString(); for (int k = 0; k &lt; temp.length(); k++) &#123; stack_res.push(temp.charAt(k)); &#125; &#125; &#125; while (stack_res.size() &gt; 0) &#123; System.out.print(stack_res.pop()); &#125; &#125; &#125;&#125; 结果12abc3&#123;as2[sd]sd3(we)2&#123;s&#125;4&#123;svf&#125;&#125;fvsfvsfvsfvsssewewewdsdsdssafvsfvsfvsfvsssewewewdsdsdssafvsfvsfvsfvsssewewewdsdsdssacba 感受(总结) 得多练啊，基础知识啊，队列的使用都不会，气人不气人！ 平时不要只做代码搬运工啊，int n = Integer.valueOf(‘2’); 得到的结果不是2，是50啊(这里是字符2，不是字符串2)； scanner.next()遇到空格会结束啊，笨蛋； 提前做好准备工作啊，建好工程，做好准备，像什么数组打印之类的。 实在做不出来，要学会骗分，通过多少测试用例应该是有分的吧！ 最后 此致，敬礼！]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程练习:只用0交换排序数组]]></title>
    <url>%2F2019%2F04%2F09%2Fprogramming-practise%2Fflx1%2F</url>
    <content type="text"><![CDATA[题目来源：华为模拟题题目描述 华为模拟测试题，蛮简单，一个长度为n的整型数组，乱序存放0至n-1，要求只能交换0和其中的一个数，对数组进行排序(也没有说升序还是降序)，交换的函数他已经写好了。给出如下结构：12345678910public class Solution &#123;public void swapWithZero(int[] array, int len, int n) &#123; Main.SwapWithZero(array, len, n); &#125;public void sort(int[] array, int len) &#123; // 完成这个函数 &#125;&#125; 要求完成这个sort函数，在sort函数中调用swapWithZero函数进行排序，注意这里的n是指要调换的数，并不是在数组中的下标！ 分析首先需要始终明确几点: 数组为[0, n-1]，是连续的，只是乱序的。 从始至终只能交换0和其中某个数。 不需要考虑怎么交换 最终排好的数组，下标和该位置上的数相同，这点非常重要 基本思想： 首先将0放到第一位上，还有1-&gt;n-1的位置上需要排序 循环n-1次，每次将一个数放到相应的位置上。这里就要用到数组的特点，第1次循环（0已经在下标为0的位置上了）将1放到下标为1的位置上，第2次循环将2放到下标为2的位置上，……，第n-1次循环，将n-1放在n-1的位置上！下面来看一下我采用的示例{4,5,0,3,1,2}首先看一下手工推导过程这里只是将1交换到相应位置处的过程！ 第一步将0和初始数组第一个数交换，将0交换到第一位。 第二步将0和1交换，将1交换到第一个位置上。 第三步将当前正在处理（循环处）的位置下标处（位置1）的数和0交换（有点绕）。 第四步将1和0交换，这样1就到了应该呆的位置上了。同时0又回到了第一个，方便下次操作！实现（java 1.8）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package sxtest20190409;/** * @ClassName: Solution * @Author: fanjiajia * @Date: 2019/4/9 下午8:12 * @Version: 1.0 * @Description: */public class Solution &#123; public static void main(String[] args) &#123; int[] array = &#123;4,5,0,3,2,1&#125;; Solution solution = new Solution(); solution.sort(array, array.length); for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + &quot; &quot;); &#125; &#125; public void sort(int[] array, int len) &#123; // 完成这个函数 // 将0移动到第一位 int firstNum = array[0]; swapWithZero(array, len, firstNum); // 还有位置1-&gt;n-1位置的数需要移动 for (int index = 1; index &lt; len; index++) &#123; //每次循环将index处放置该位置应该的数（index本身） swapWithZero(array,len, index); // 将index 放在首位 int indexNum = array[index]; swapWithZero(array, len, indexNum); swapWithZero(array, len, index); &#125; &#125; public void swapWithZero(int[] array, int len, int n) &#123; Main.SwapWithZero(array, len, n); &#125;&#125;class Main &#123; /** * 交换数组中0和n * @param array * @param len * @param n */ public static void SwapWithZero(int[] array, int len, int n) &#123; /** * 1 0的位置更改为n * 2 n的位置改为0 */ for (int i = 0; i &lt; len; i++) &#123; if (array[i] == 0) &#123; array[i] = n; &#125; else if (array[i] == n) &#123; array[i] = 0; &#125; &#125; &#125;&#125; 这里自定义实现了Main类，以及其中的SwapWithZero函数，这里交换相对简单，直接赋值即可。 最后 此致，敬礼]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Eclipse项目导入到Android Studio中]]></title>
    <url>%2F2019%2F03%2F13%2Fkits%2Fflx2%2F</url>
    <content type="text"><![CDATA[背景 最近需要将Eclipse中的android项目导入到Android Studio中！倒腾一番，记录如下！ 步骤1打开Android Studio（下文称AS），选择Import project(Gradle,Eclipse ADT,etc),定位到你需要导入的主项目，切记是主项目，比如下图XXXX_JX是我的主项目，上面的为我主项目中的依赖项，该项先不管，后继操作！ 步骤2下一步会有如下提示：英文意思很明显，就是转换后的项目是一个全新的项目，不会改变之前的项目，这里需要给转换后的新项目制定一个地址。 步骤3随后提示如下：上面两个勾不用管，默认勾上，下面的一个勾代表意思是是否将moudel按照驼峰命名规则进行命名，默认是勾选的，看个人喜好，这里我为了保持之前的习惯，就不勾选了。 步骤4下一步提示如下：这一步不一定都会有，我先前写的一个简单helloworld转换时就没有提示，那么如果提示了就删掉原来项目下的隐藏文件.settings .classpath .project。如下图原因是AS检测到之前Eclipse中的项目是不兼容的。 完成上面的操作之后，就可以等待AS慢慢转换了。 步骤5转换完后，AS会打开名为:import-summary.txt文件，从名字看，就是最后总结文件了，其中记录了许多重要的信息。这里说两点比较重要的(个人认为) Ignored Files，表示忽视的文件，说明不重要，如果你检查有重要的文件，就需要手动copy过来了。 Replaced jars with Dependencies，意思是将之前项目中某些jar包或者依赖项转为在线依赖了，也就是通过gradle实现。 其他的也就没什么了，这里我的项目没有多余操作，所以不需要再进行额外操作！这个时候项目就可以在AS中编译了，考虑到eclipse中的项目可能比较久远，那么很可能有些会报错，比如我的项目报错意思就是gradle-2.4.1过时了，此时，修改gradle的版本为当前版本就可以了 步骤6之前说的依赖项，在AS中称为Module，因此我们 New Moudle，选择Import Eclipse ADT Project即可！最后添加Moudle的依赖即可！ 最后 此致，敬礼！]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo设置permalink-避免url中出现中文]]></title>
    <url>%2F2019%2F03%2F12%2Fkits%2Fflx1%2F</url>
    <content type="text"><![CDATA[hexo博客初始化的url是年月日+题目:year/:month/:day/:title/，这样的url不便与分享，中文会乱吗，而且一旦修改了题目（我相信大部分人的题目都是中文）就会导致之前分享的url无法定位资源。 解决方案一（不建议使用） 在每次发布的文章开始的Front-matter中加入urlname字段，表示每次自己url需要自己给定。比较繁琐 解决方案二（广泛采用） 使用插件abbrlink,但不知道为何，我没能成功安装。 本文方案第一步在_config.yml文件中修改permalink12permalink: :year/:month/:day/:category/:id/permalink_defaults: 第二步配置categroy_map同样在_config.yml中修改category_map, 这里的配置就是将很多category是中文的映射成英文，下文是我的配置！123456789101112131415# Category &amp; Tagdefault_category: uncatalog## 为了让中文分组名在网址中显示为英文，我们可以创建分组名映射（category_map）：category_map: Android: android Android Studio: android-studio C#: Cplusplus Python: Python SQL: sql 工具: kits 微信小程序: wxxcx 数据库: database 杂记: petty 编程练习: programming-practisetag_map: 第三步再看看第一步的配置中permalink: :year/:month/:day/:category/:id/其中有 /:id 这个id是自己添加的，因此需要在scaffolds/post.md中添加id，如下:1234567---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;id: tags: categories: --- 这就意味着自己每次发布时需要为其制定category和id，id可以自己随便给，同一分类同一天不要重复就好！可以自己给一些有代表意思的标记, 比如我的flx1（范爱夏）,表示今天写的第一篇； 最后 此致，敬礼！]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程练习：无重复字符的最长字串]]></title>
    <url>%2F2019%2F03%2F12%2Fprogramming-practise%2Fflx1%2F</url>
    <content type="text"><![CDATA[题目LeetCode-无重复字符的最长字串 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例1123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例2123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 分析与实现解法一 分析这里面的难度在于，从i开始遍历，遇到相同字符后结束，记录长度。然后从i+1开始继续遍历 实现（java）12345678910111213141516171819202122232425262728293031/** * 求不出现重复的最大字串的长度 * @param s 源串 * @return 长度值 */ public static int lengthOfLongestSubstring(String s) &#123; if (s.length() &lt; 2) &#123; return s.length(); &#125; int maxLen = 0; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (int i = -1; i &lt; s.length(); i++)&#123; list.clear(); // 每次清空map //list.add(s.charAt(i)); for (int j = i+1; j &lt; s.length(); j++) &#123; Character c = s.charAt(j); if (!list.contains(c))&#123; list.add(c); &#125;else&#123; // 说明存在了 break; &#125; &#125; if (list.size() &gt; maxLen) &#123; maxLen = list.size(); &#125; &#125; return maxLen; &#125; 这里使用了list作为字串的存储，主要是便于判断字符的存在情况，用了两次for循环 这样做的确可以达到效果，但是时间复杂度很大，提交结果如下 解法二 分析在每一次遍历到一个重复的字符时，其实在这之前的所有字符已经遍历，那么应该可以直接拿来用，所以这里分为三种情况： 情况1: 重复字符出现在子串的第一位； 情况2: 重复字符出现在子串的中间； 情况3: 重复字符出现在子串的最后； 关于这三种情况的处理详细见下面的代码中的注释分析： 实现（java）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657if (s.length() &lt; 2) &#123; return s.length(); &#125; int maxLen = 0; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; s.length(); j++) &#123; Character c = s.charAt(j); if (!list.contains(c))&#123; list.add(c); &#125;else&#123; int index = list.indexOf(c); // 得到列表中该字符的下标 /* 1. 如果下标在最开始 判断list的size和max的大小 将第一个remove掉 将新的字符加入list */ if (index == 0)&#123; if (list.size() &gt; maxLen) &#123; maxLen = list.size(); &#125; list.remove(0); &#125; /* 2. 如果下标在最中间 判断前面部分的长度是否大于当前的maxlen，如果是修改maxlen 将index出之前(包括index出的字符)删除 将j处的字符加入list */ else if (index != 0 &amp;&amp; index != (list.size() - 1)) &#123; if (list.size() &gt; maxLen) &#123; maxLen = list.size(); &#125; for (int i = 0; i &lt; index + 1; i++) &#123; list.remove(0); // 移除index+1次；list的remove问题 &#125; &#125; /* 3. 如果下标在最最后 判断size和maxlen的大小 清除list中所有的元素 将j处的字符加入 */ else &#123; if (list.size() &gt; maxLen) &#123; maxLen = list.size(); &#125; list.clear(); &#125; list.add(c); &#125; &#125; if (list.size() &gt; maxLen) &#123; // 判断最后list中的字串长度 maxLen = list.size(); &#125; return maxLen; 这样处理后，在时间复杂度上好了很多！当然LeetCode上还有很多大佬的实现，时间复杂度还要低，但是思想都是重复利用遍历过序列 最后 此致，敬礼！]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac下安装OpenCV问题]]></title>
    <url>%2F2019%2F03%2F09%2FPython%2Fflx1%2F</url>
    <content type="text"><![CDATA[最近看了纹理特征方面的paper，看了一些资料之后，想要实际动手实现一下其中LBP算法，果然OpenCV中已经实现。 问题 No module named “cv2”当我在我们项目顶部import cv2时，提示没有cv2模块，换言之就是没有安装openCV，好吧！ 安装出错运行1pip install cv2 报错 解决1pip install opencv-python 此致，敬礼]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程练习:两数相加]]></title>
    <url>%2F2019%2F03%2F09%2Fprogramming-practise%2Fflx1%2F</url>
    <content type="text"><![CDATA[编程练习: 两数相加题目-LeetCode 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 分析 这其实是链表的操作，在之前数据结构中很常见，对两个链表进行操作； 另外这里两数被表示成链表形式，比如2-&gt;4-&gt;3 个位是2，十位是4，百位是3；其实可以按照算术中的加法，个位与个位相加、、、，所以这样就比较简单了；链表长度 两个链表长度相同比较好处理，但是还要注意链表长度不一样带来的问题；详细见代码分析！实现（java）节点表示12345678/** * 列表节点定义 */class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x;&#125;&#125; 处理函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * 两个数相加 * @param l1 * @param l2 * @return */ public static ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; // 以l1为返回列表 ListNode moveNode = l1; // 移动节点 ListNode tempNode = null; int outNum = 0; // 1. 处理前面两个节点相加部分 while (l2 != null &amp;&amp; moveNode != null) &#123; int value = l2.val + moveNode.val + outNum; moveNode.val = value % 10; outNum = value / 10; if (moveNode.next == null)&#123; tempNode = moveNode; // 最后一个节点记录下来 &#125; moveNode = moveNode.next; l2 = l2.next; &#125; // 2. 处理列表超长 if (l2 == null &amp;&amp; moveNode != null)&#123; if (outNum != 0)&#123; // moveNode != null while (moveNode != null) &#123; int value = moveNode.val + outNum; moveNode.val = value % 10; outNum = value / 10; if (moveNode.next == null)&#123; break; &#125; moveNode = moveNode.next; &#125; &#125; &#125;else if( moveNode == null &amp;&amp; l2 != null)&#123; tempNode.next = l2; tempNode = l2; if (outNum != 0)&#123; // l2 != null while (tempNode != null) &#123; int value = tempNode.val + outNum; tempNode.val = value % 10; outNum = value / 10; if (tempNode.next == null)&#123; break; &#125; tempNode = tempNode.next; &#125; &#125; &#125;else&#123; if (outNum != 0)&#123; // 两个长度一样 ListNode node = new ListNode(outNum); tempNode.next = node; &#125; &#125; // 如果上面一直相加超过10，则最后溢出位处理之 if (outNum != 0) &#123; ListNode node = new ListNode(outNum); if (moveNode != null)&#123; moveNode.next = node; &#125;else &#123; tempNode.next = node; &#125; &#125; return l1; &#125; 这段代码中还可以优化，当时在提交到LeetCode不正确后，变只图通过测试，没有考虑到性能！ 主函数调用123456789101112131415161718192021222324public static void main(String[] args) &#123; ListNode l1 = new ListNode(9); ListNode node1 = new ListNode(8); ListNode node2 = new ListNode(3); l1.next = node1; node1.next = node2; ListNode l2 = new ListNode(9); ListNode node3 = new ListNode(9); ListNode node4 = new ListNode(4); l2.next = node3; node3.next = node4; ListNode nodes = addTwoNumbers(l1, l2); while (nodes != null) &#123; if (nodes.next != null)&#123; System.out.print(nodes.val + &quot;-&gt;&quot;); &#125;else &#123; System.out.print(nodes.val); &#125; nodes = nodes.next; &#125; &#125; 结果18-&gt;8-&gt;8 最后 此致，敬礼！]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程练习-快速寻找满足条件的两个数]]></title>
    <url>%2F2019%2F03%2F07%2Fprogramming-practise%2Fckfv9onsb003wqxlpc3wlevef%2F</url>
    <content type="text"><![CDATA[题目-来自编程之美 给定一个数组，快速从其中找出两个数满足其之和等于给定的数，这里假设其中至少存在一组符合要求的解； 分析这里的关键在于快速 最为愚钝的方式当然是：穷举，从数组中任意取出两个数字进行判断，但是时间复杂度为$O(N^2)$; 一般是数组，首先进行排序，采用时间复杂度为$O(Nlog_2N)$, 然后通过一次遍历求出所需的解，时间复杂度为$O(N)$， 所以整个时间复杂度为$O(Nlog_2N)$， 书中分析： 令i = 0, j = n - 1, 查看arr[i] + arr[j]是否等于sum，如果是则结束，否则判断大小，如果小于sum，则i++,否则j--, 这样从两端向中间移动，则一定会找到的。 同时我借助快排思想中移动，上面每次只移动一个位置，能不能一次移动多个，这样在两个目标数距离比较近时，能过更加快速的找到。详见代码！事实证明可行！ 实现(java)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.jiajia.find;/** * @ClassName: FindTowNum * @Author: fanjiajia * @Date: 2019/3/7 下午7:28 * @Version: 1.0 * @Description: 在一个序列中快速查找两个满足条件的两个数 */public class FindTowNum &#123; public static void main(String[] args) &#123; int[] arr = &#123;2,3,9,5,7,8,4,6&#125;; function(arr, 14); &#125; private static void function(int[] arr, int targetNum) &#123; // 先排序（从小到大） quickSort(arr, 0, arr.length - 1); // 方法1：每次只移动一个下标 boolean flag = false; // 方法1是否寻找到 for (int i = 0, j = arr.length - 1; i &lt; j; )&#123; if (arr[i] + arr[j] == targetNum)&#123; System.out.println(&quot;方法1-&gt;存在两个数，分别为:&quot; + arr[i] + &quot;,&quot; + arr[j]); flag = true; break; &#125;else if (arr[i] + arr[j] &lt; targetNum)&#123; i++; &#125;else &#123; j--; &#125; &#125; if (!flag)&#123; System.out.println(&quot;不存在&quot;); &#125; // 方法2 int i = 0, j = arr.length - 1; while (i &lt; j &amp;&amp; (arr[i] + arr[j] != targetNum)) &#123; // i 和 j不可能重合 while (arr[i] + arr[j] &lt; targetNum &amp;&amp; i &lt; j) &#123; // 移动i i++; &#125; while (arr[i] + arr[j] &gt; targetNum &amp;&amp; i &lt; j) &#123; // 移动j j--; &#125; &#125; if (i &lt; j)&#123; System.out.println(&quot;方法2-&gt;存在两个数，分别为:&quot; + arr[i] + &quot;,&quot; + arr[j]); &#125;else &#123; System.out.println(&quot;不存在&quot;); &#125; &#125; /** * 快排 * @param arr * @param left * @param right */ private static void quickSort(int[] arr, int left, int right)&#123; if (left &gt;= right) &#123; // 必须加 return; &#125; int temp = arr[left]; // 以左边的元素为基准元素 int i = left, j = right; // i,j为两个游标 while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt;= temp)&#123; // 右边先走 j--; &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= temp) &#123; i++; &#125; if (i &lt; j) &#123; swap(arr, i, j); &#125; &#125; arr[left] = arr[i]; // 注意，这一步必须要，填上最左边的坑 arr[i] = temp; // 基准元素就位 quickSort(arr, left, i - 1); // 递归操作左边部分 quickSort(arr, i + 1, right); // 递归操作右边部分 &#125; /** * 交换两个元素 * @param arr * @param i * @param j */ private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 最后 此致，敬礼！]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程实现Excel执行分类多条件汇总合并]]></title>
    <url>%2F2019%2F03%2F05%2FCplusplus%2Fckfv9ons6003fqxlpgnhgyuol%2F</url>
    <content type="text"><![CDATA[之前发了一片模拟合并，详见模拟Excel同一列相同值的单元格合并 在之前的文章中介绍了思想，其中Excel采用的二维数组模拟，今天花了点时间，学习了一下C#操作Excel，实现了类似的效果！ 准备需要导入Microsoft.Office.Interop.Excel;1using Microsoft.Office.Interop.Excel; 实现关键函数：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/// &lt;summary&gt; /// /// &lt;/summary&gt; /// &lt;param name=&quot;sheet&quot;&gt;&lt;/param&gt; private static void ExecutMerge(Worksheet sheet) &#123; int begainIndex = 2; // 开始行, Excel下标从1开始,第一行是标题行 int endIndex = GetEndIndex(sheet, begainIndex, 1, sheet.UsedRange.Rows.Count); // 查找最开始第一列从1（下标0）行开始值相同的最后一行下标 // 外围控制，第一列的合并 while (begainIndex &lt;= sheet.UsedRange.Rows.Count) &#123; MergeContorl(sheet, begainIndex, endIndex, 1); // 递归执行 begainIndex = endIndex + 1; // 第一列下一次执行行开始下标 endIndex = GetEndIndex(sheet, endIndex + 1, 1, sheet.UsedRange.Rows.Count); &#125; &#125; /// &lt;summary&gt; /// 递归控制器 /// &lt;/summary&gt; private static void MergeContorl(Worksheet sheet, int rowbeg, int rowend, int col) &#123; // 1. 执行当前的合并操作 Merge(sheet, rowbeg, rowend, col); // 2.执行后面的操作 if (col &gt; 6) &#123; // 只合并前面6列，递归结束条件 return; &#125; // 3.执行后面列的操作 for (int i = rowbeg; i &lt;= rowend; i++) &#123; int begin = i; int end = GetEndIndex(sheet,begin, col + 1, rowend); while (begin &lt;= rowend) &#123; // 这里保证后面所有的行都能遍历到 MergeContorl(sheet, begin, end, col + 1); // 开启递归 begin = end + 1; end = GetEndIndex(sheet, begin, col + 1, rowend); &#125; &#125; &#125; /// &lt;summary&gt; /// 合并 /// &lt;/summary&gt; private static void Merge(Worksheet sheet, int rowbeg, int rowend, int col) &#123; //sheet.get_Range(sheet.Cells[rowbeg, col], sheet.Cells[rowend, col]).MergeCells = true; sheet.Range[sheet.Cells[rowbeg, col], sheet.Cells[rowend, col]].MergeCells = true; for (int i = rowbeg + 1; i &lt;= rowend; i++) &#123; sheet.Cells[i, col] = &quot; &quot;; &#125; &#125; /// &lt;summary&gt; /// 获取同一列相同值得最后（行）下标 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static int GetEndIndex(Worksheet sheet, int begrow, int col, int endscope) &#123; if (begrow &gt;= endscope || begrow &gt;= sheet.UsedRange.Rows.Count) // sheet的行下标从0开始 &#123; return begrow; &#125; if(((Range)sheet.Cells[begrow, col]).Text ==( (Range)sheet.Cells[begrow + 1, col]).Text) &#123; return GetEndIndex(sheet, begrow + 1, col, endscope); &#125; else &#123; return begrow; &#125; &#125; main函数12345678910111213141516171819202122232425static void Main(string[] args) &#123; // 1. 打开excel文件 Application app = new Application(); app.AlertBeforeOverwriting = false; app.DisplayAlerts = false; // 避免合并单元格时频繁的提示 Workbooks wbks = app.Workbooks; Workbook wbk = wbks.Add(@&quot;C:\XXXXXX\Desktop\test.xlsx&quot;); // 打开Excel文件 Worksheet sheet = (Worksheet)wbk.Sheets.get_Item(1); // 获取sheet // 执行合并 ExecutMerge(sheet); // 合并完成另存为一个文件 wbk.SaveAs(@&quot;C:\XXXXXX\Desktop\result.xlsx&quot;, Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value, Microsoft.Office.Interop.Excel.XlSaveAsAccessMode.xlNoChange, Missing.Value, Missing.Value, Missing.Value, Missing.Value, Missing.Value); // 资源的关闭释放 wbk.Save(); wbk.Close(); app.Quit(); Console.WriteLine(&quot;执行结束&quot;); Console.ReadLine(); &#125; 可以看出，只要得到一个sheet，直接调用ExecutMerge(sheet);即可； 效果 原表 结果最后 此致, 敬礼]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F2019%2F03%2F05%2Fprogramming-practise%2Fckfv9onsv004tqxlppxq09wve%2F</url>
    <content type="text"><![CDATA[思想 所谓贪心算法，就是在走的每一步都不考虑后面的操作，即不考虑全局，只关注当下，即寻找局部最优解，因此贪心算法，并不能保证找到全局最优解。实际上，贪心算法用得很少，除非在已知使用贪心算法能过找到最优解时使用。贪心算法在作出每一步的决策之后，将不可改变 例子 有如下的一个任务序列{1,2,3,4,5},表示5个任务 有T = {5, 8, 4, 10, 3};, 表示执行这5个任务需要的时间 有D = {10, 15, 20, 18, 30};，表示这个5个任务期望完成的时间，这是一个时间点，即时刻，上面T表示的是一段时间，比如5分钟。需求 如果所有的任务都执行，求出每个任务的延迟，以及最大的延迟。 对于有延迟的任务，直接不执行，求出满足不延迟的任务序列实现(java)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.Scanner;/** * @ClassName: GreedyMain * @Author: fanjiajia * @Date: 2019/3/4 下午8:44 * @Version: 1.0 * @Description: 贪心算法 */public class GreedyMain &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in);// System.out.print(&quot;请输入任务:n = &quot;);// int n = scanner.nextInt();// System.out.println();// int T[] = new int[n];// int D[] = new int[n];// System.out.println(&quot;请输入每个任务完成需要的时间:&quot;);// for (int i = 0; i &lt; n; i++) &#123;// T[i] = scanner.nextInt();// &#125;// System.out.println(&quot;请输入每个任务希望完成的时间点:&quot;);// for (int i = 0; i &lt; n; i++) &#123;// D[i] = scanner.nextInt();// &#125; int n = 5; int[] T = &#123;5, 8, 4, 10, 3&#125;; int[] D = &#123;10, 15, 20, 18, 30&#125;; // 1. 对希望完成的任务进行排序，从小到大 for (int i = 0; i &lt; D.length; i++) &#123; for (int j = 0; j &lt; D.length - i -1; j++) &#123; // 因为i从0开始，确保最后一个 if (D[j] &gt; D[j + 1]) &#123; // 这里有j+1，说明为什么上面-1 swap(D, j, j + 1); swap(T, j, j + 1); &#125; &#125; &#125; // 2. 所有的任务都执行，求最大的延迟 int maxDelayTime = 0; // 最大的延迟时间 int curTime = 0; // 当前完成时间点 int index = -1; // 记录是哪一个任务被延迟 for (int i = 0; i &lt; n; i++) &#123; curTime += T[i]; if (curTime &gt; D[i]) &#123; // 说明此任务需要延迟 if (curTime - D[i] &gt; maxDelayTime) &#123; maxDelayTime = curTime - D[i]; // 更新最大延迟时间 index = i; &#125; &#125; &#125; System.out.println(&quot;当前任务序列第&quot; + (index + 1) +&quot;个的延迟最大,为:&quot; + maxDelayTime); // 这里排序了，下标不准确 curTime = 0; // 3. 不满足的任务不执行，获取可以执行的任务 for (int i = 0; i &lt; n; i++) &#123; curTime += T[i]; if (curTime &lt; D[i]) &#123; // 说明此任务满足 System.out.print(i + &quot; &quot;); &#125; &#125; &#125; /** * 交换数组中的两个元素 * @param arr * @param i * @param j */ private static void swap(int[] arr, int i, int j) &#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125;&#125; 这里的操作并不严谨，因为数组排序后，序列发生改变，因此在实际的贪心算法中，多用对象表示。很好的贪心算法是，背包问题，零钱找零问题，，，（详细见参考资料） 参考资料https://www.cnblogs.com/xsyfl/p/6938642.htmlhttps://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.htmlhttps://blog.csdn.net/cwh0908/article/details/80193312 最后 此致，敬礼]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[模拟Excel同一列相同值的单元格合并]]></title>
    <url>%2F2019%2F03%2F04%2Fprogramming-practise%2Fckfv9ons20034qxlpb533zuat%2F</url>
    <content type="text"><![CDATA[背景 项目中有一个查询工作量，可以将查询的结果导出到Excel表中。在Excel工具中，有一个合并居中功能，可以将选中的单元格合并成一个大的单元格。现在需要在程序中直接实现查询结果的汇总 问题分析话不多说，上图分析：如图，对于第一列，前三行的值都为A，那么就是需要执行合并。与此同时，1-3行后面的列采取同样的措施，约定前6列（下标0-5）。手动对1-3列进行分析的结果，如图，有点花哨！！！可以看到结果中，对于整个1-3行后继的列操作依然如此。 这里要突出讲一下第3列（值为R），该列全部为R，但是，在第二列中，前两行的值一样为F，第三行的值为D，这里就说明前两行应该拿在一起看了，而第三行需要单独分割开来，即使后面的列取值相同。 思想这里的难点是如何确保第一列之后的列能够按照需求进行合并，同时像上面分析中提出的第三列，虽然取值相同，但是只能合并前两列。如果只合并第一列中相同的值，那么很简单，确定开始行标，结束行标，执行合并即可。对于第一列，最开始的下标是0，最后的下标是整个表的行数-1，这是遍历范围。其实发散来看，后面的操作和第一列一样，不同在于确定开始和结束的下标，以及范围。 对于第2列，范围就是第一列确定的范围，是一个值，比如示例中第2行范围为1-3。 对于第3列，范围来自第2列，但是要注意，这里大范围仍然是1-3，但是里面却要区分为1-2，和3，其实到这里就可以看出递归的思想了。实现代码（利用java二维数组模拟实现）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** * @ClassName: Demo * @Author: fanjiajia * @Date: 2019/3/2 下午8:14 * @Version: 1.0 * @Description: 模拟Excel表合并操作 */public class Demo &#123; public static void main(String[] args) &#123; int[][] arr = &#123; &#123;1,2,3,4,6,6,7,8,3&#125;, &#123;1,2,3,4,6,8,9,8,5&#125;, &#123;1,8,3,4,5,6,7,8,6&#125;, &#123;4,2,3,4,5,6,7,8,7&#125;, &#123;1,2,5,4,5,6,7,8,8&#125;, &#123;1,2,5,4,5,7,7,8,6&#125;, &#123;1,3,3,4,6,6,7,8,8&#125;, &#123;1,3,3,4,5,7,7,8,9&#125;, &#125;; // 1.开始执行合并 executMerge(arr); // 2.合并结束，打印结果 for(int i = 0; i &lt; arr.length; i++) &#123; for (int j = 0; j &lt; arr[0].length; j++) &#123; System.out.print(arr[i][j] + &quot;,&quot;); &#125; System.out.println(); &#125; &#125; private static void executMerge(int[][] arr) &#123; int begainIndex = 0; // 开始行，0行 int endIndex = getEndIndex(0,arr, 0, arr.length); // 查找最开始第一列从1（下标0）行开始值相同的最后一行下标 // 外围控制，第一列的合并 while (begainIndex &lt; arr.length)&#123; mergeContorl2(arr, begainIndex, endIndex, 0); // 递归执行 begainIndex = endIndex + 1; // 第一列下一次执行行开始下标 endIndex = getEndIndex(endIndex + 1, arr, 0, arr.length); // 获取下次结束的下标 &#125; &#125; /** * 递归执行 * @param arr 表 * @param rowbeg 行开始下标 * @param rowend 行结束下标 * @param col 列下标 */ private static void mergeContorl2(int[][] arr, int rowbeg, int rowend,int col) &#123; // 1. 执行当前的合并操作 merge(arr, rowbeg, rowend, col); // 2.执行后面的操作 if (col &gt; 5) &#123; // 只合并前面6列，递归结束条件 return; &#125; // 3.执行后面列的操作 for (int i = rowbeg; i &lt;= rowend; i++) &#123; int begin = i; int end = getEndIndex(begin, arr, col +1,rowend); while (begin &lt;= rowend)&#123; // 这里保证后面所有的行都能遍历到 mergeContorl2(arr,begin,end, col +1); // 开启递归 begin = end +1; end = getEndIndex(begin, arr, col + 1, rowend); &#125; &#125; &#125; /** * 执行合并操作 * @param arr 表 * @param begin 开始行下标 * @param end 结束行下标 * @param col 列 */ private static void merge(int[][] arr,int begin, int end, int col)&#123; for(int row = begin; row &lt;= end; row++) &#123; arr[row][col] = row == begin? arr[begin][col] : 0; &#125; &#125; /** * 获取同一列相同的值的最后（行）下标 * @param i 当前行下标 * @param arr 表 * @param j 列 * @param endIndex 约束最多遍历至第几行 * @return */ private static int getEndIndex(int i, int[][] arr, int j, int endIndex) &#123; if (i &gt;= endIndex || i &gt;= (arr.length -1))&#123; // return i; &#125; if (arr[i][j] == arr[i+1][j])&#123; return getEndIndex(i+1, arr, j,endIndex); // 开启递归 &#125;else &#123; return i; &#125; &#125;&#125; 结果 输入 12345678&#123;1,2,3,4,6,6,7,8,3&#125;,&#123;1,2,3,4,6,8,9,8,5&#125;,&#123;1,8,3,4,5,6,7,8,6&#125;,&#123;4,2,3,4,5,6,7,8,7&#125;,&#123;1,2,5,4,5,6,7,8,8&#125;,&#123;1,2,5,4,5,7,7,8,6&#125;,&#123;1,3,3,4,6,6,7,8,8&#125;,&#123;1,3,3,4,5,7,7,8,9&#125;, 输出 123456781,2,3,4,6,6,7,8,3,0,0,0,0,0,8,9,8,5,0,8,3,4,5,6,7,8,6,4,2,3,4,5,6,7,8,7,1,2,5,4,5,6,7,8,8,0,0,0,0,0,7,7,8,6,0,3,3,4,6,6,7,8,8,0,0,0,0,5,7,7,8,9, 说明，合并操作用0表示，比如第一列1，下面2个0，表示这三行执行合并，值为1. 最后 此致，敬礼]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多条件的批量操作]]></title>
    <url>%2F2019%2F02%2F23%2FSQL%2Fckfv9onrn0025qxlpfloc0xg7%2F</url>
    <content type="text"><![CDATA[通常在sql语句中需要多条记录同时进行删除、修改、查询，如果操作的记录有一个唯一确定的主键，那么通过primary_id = ‘value’，可以很容易实现，即使是需要满足这个字段有多种值时也可以where 后 用in，但是如果有3个、4个字段确定需要操作的多条记录呢？ 同样用in比如表table有字段id1，id2，id3，id4，id5，id6，现在需要对id6进行修改，但是由id1-4唯一确定一个id6 1update table set id6=&apos;value&apos; where (id1,id2,id3,id4) in((&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;),(&apos;1&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;)......) 同样是in的思想，但是对于不同的数据库可能实现不一样，似乎mysql不行，具体没有试过 最后 此致，敬礼]]></content>
      <categories>
        <category>SQL</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac下离线安装SDK]]></title>
    <url>%2F2019%2F01%2F15%2FAndroid%2Fckfv9onre001gqxlpyeknpi1e%2F</url>
    <content type="text"><![CDATA[背景 之前电脑上使用的是Android Studio,其sdk在Libarey下，最近需要在Eclipse下继续做之前的安卓项目，在配置sdk时eclipse自动选择了之前Android Studio的sdk路径，一开始运行抱错，网上解决方案时复制一份sdk到另外的路径，给Eclipse配置不同于Android Studio的sdk路径，但是问题依然存在，而且压根运行不起来。 在线安装被墙得痛苦虽然很多说什么配置SDK Manager的代理，什么大连软件信息学院的镜像等等，但是我从没有成功，索性采用离线安装的方式。 离线解决方案准备SDK Manager首先需要清楚这个网站https://www.androiddevtools.cn/这里面有我们需要的所有内容，主要是不需要翻墙，不需要翻墙。第一步下载SDK Tools下载之后解压缩得到你需要存放sdk的目录，可以看到文件解压缩后就是android-sdk-macos，所以这就表明，这个文件下就是所有的sdk内容。也即是Eclipse中设置sdk的路径。 打开SDK Manager 窗口在windows下一半点击.exe文件，即可打开窗口，但是在mac中需要用命令行的方式打开，首先命令行切换到tools，目录下，使用1./android sdk 注意前面的那个.，这时候Manager窗口打开。 下载SDK可以看到这里SDK是和Android版本相关的，这里最新的居然只是21，也就是android 5，有点落后，但是21够用了。按照他文字描述的进行操作即可。 下载Build Tools同样按照指示的操作进行，选择和你下载的SDK版本相同的tool。 下载platform-tools 到这里其实SDK就安装好了，有人说还有什么platform-tools，我们来看一下他的说明，需要使用adb命令时才需要，但是小白应该不需要吧，如果你觉得有必要也按照指示操作即可。 到这里，基本上就可以进行真机上的开发了。但是如果需要创建模拟器，那你就需要安装 SDK System images 到这里，基本就结束了，在Eclipse中指定Android sdk路径即可。 最后 生命不止，使劲造吧]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程练习：寻找发帖"水王"扩展问题二]]></title>
    <url>%2F2018%2F12%2F20%2Fprogramming-practise%2Fckfv9onsp004eqxlpegdgq0wn%2F</url>
    <content type="text"><![CDATA[回顾 在前面两篇文章已经实现了水王id出现次数超过一半,以及水王id出现次数刚好一半 分析 借助上面水王id出现次数刚好出现一半的分析，其实这里就是找出数组中出现次数前三的元素,具体的分析，见前面两篇文章，其实问题的实质以及分析的基本方向都是相似的。 实现123456789101112131415161718192021222324252627282930313233/** * @Author fanjiajia * @Date 下午8:50 2018/12/20 * @Description 长度为N的数组中有3个元素，出现次数都超过N/4,找出这3个元素 **/ public &lt;T&gt; T[] func4(T[] arr) &#123; T[] candidates = (T[]) new Object[3]; int[] nTimes = &#123;0,0,0&#125;; for (int i = 0; i&lt; arr.length; i++) &#123; if (nTimes[0] == 0) &#123; candidates[0] = arr[i]; nTimes[0] = 1; &#125;else if (nTimes[1] == 0) &#123; candidates[1] = arr[i]; nTimes[1] = 1; &#125;else if (nTimes[2] == 0) &#123; candidates[2] = arr[i]; nTimes[2] = 1; &#125;else if (candidates[0] == arr[i]) &#123; nTimes[0]++; &#125;else if (candidates[1] == arr[i]) &#123; nTimes[1] ++; &#125;else if (candidates[2] == arr[i]) &#123; nTimes[2] ++; &#125;else &#123; nTimes[0] --; nTimes[1] --; nTimes[2] --; &#125; &#125; return candidates; &#125; 最后 生命不息，使劲造]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程练习：寻找发帖"水王"扩展问题一]]></title>
    <url>%2F2018%2F12%2F20%2Fprogramming-practise%2Fckfv9onsj0046qxlpbcwyt6d2%2F</url>
    <content type="text"><![CDATA[回顾 寻找发帖水王的问题总结起来就是在一个数组中某一个元素出现次数超过了数组长度的一半，那么可以很顺利的找到这个元素，实现见“编程练习:寻找发帖水王” 扩展 上面的问题中，强调了某一个元素出现次数超过了数组长度的一半，那么试想一下，如果这个元素刚好只有一半, 比如{1,2,3,1,2,1};那么按照上面的思路和实验结果，其结果是2，显然出现和预期不符合的答案。 分析其实可以发现这个元素刚好只出现了一半，那么我们可以在遍历时同时预备两个元素，该思想要达到的效果就是能够找出数组中出现次数第一和第二多的两个变量，那么问题就迎刃而解。 实现直接上代码, 相应的分析，上面的文章已经很透彻1234567891011121314151617181920212223242526/** * @Author fanjiajia * @Date 下午8:11 2018/12/20 * @Description 数组中某个元素出现次数刚好只有数组长度的一半，找出它 **/ public &lt;T&gt; T func3(T[] arr) &#123; T[] candidates = (T[]) new Object[2]; // 泛型类数组的创建 int[] nTimes=&#123;0,0&#125;; for (int i = 0; i &lt; arr.length; i++) &#123; if (nTimes[0] == 0) &#123; candidates[0] = arr[i]; nTimes[0] = 1; &#125;else if (nTimes[1] == 0) &#123; candidates[1] = arr[i]; nTimes[1] = 1; &#125;else if (candidates[0] == arr[i]) nTimes[0] ++; else if (candidates[1] == arr[i]) nTimes[1] ++; else &#123; nTimes[0]--; nTimes[1]--; &#125; &#125; return nTimes[0] &gt; nTimes[1]? candidates[0]:candidates[1]; &#125; 最后 生命不息，使劲造]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程练习：寻找发帖"水王"]]></title>
    <url>%2F2018%2F12%2F20%2Fprogramming-practise%2Fckfv9onsn004aqxlp6x51wtup%2F</url>
    <content type="text"><![CDATA[题目: 寻找发帖”水王” 来源: 编程之美分析 衍生：就是给定一个数组，其中某个元素出现次数超过了数组长度的一半，找出这个元素 方法s方法1对这个串进行遍历，同时对出现的元素进行计数，可以用map，最后遍历map取出计数值最大的那个元素方法2可以对数组进行排序，第N/2个元素就是所求，下表从0开始方法3上面两个方法都有排序操作，时间复杂度不可观。 可以一次遍历, 在遍历过程中删除两个不同的元素(不管是不是出现次数最多的那个元素)，最后剩下的就是所求。 实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @ClassName: Demo1 * @Author: fanjiajia * @Date: 2018/12/19 下午8:35 * @Version: 1.0 * @Description: 某个字符串数组中存在出现次数超过该数组长度一半的某一个串，找出来 */public class Demo1 &#123; public static void main(String[] args) &#123; String strs[] = &#123;&quot;a&quot;,&quot;3&quot;, &quot;a&quot;, &quot;d&quot;,&quot;a&quot;, &quot;4&quot;,&quot;6&quot;,&quot;a&quot;, &quot;a&quot;&#125;; System.out.println(func1(strs)); &#125; /** * @Author fanjiajia * @Date 下午9:03 2018/12/19 * @Description **/ public static String func1(String[] strs) &#123; /* 方法一: 遍历一次，对每一个串出现的次数进行累计 方法二: 按照出现的次数进行排序，第N/2个必然是这个串，下标从0开始 方法三: 上面的方法都会出现排序，时间复杂度高，可以一次遍历，直接获取 每一次删除其中两个不同的串，那么最后剩下的必然是我们所需要的 */ String candidate = &quot;&quot;; // 保存可能是那个串 int nTimes, i; // nTimes操作逻辑：与之不匹配消除一对id时减少1，否则加1 for (i = nTimes = 0; i &lt; strs.length; i++) &#123; if (nTimes == 0) &#123; // ==0 说明遍历过程前面的都已经配对消除了 candidate = strs[i]; nTimes = 1; &#125;else &#123; // 说明前面有某个串没有完全配对消除 if (strs[i] == candidate) // 当前串和那个串相同，则计数值+1，否则用当前这个不同的串进行消除 nTimes ++; else nTimes --; &#125; &#125; return candidate; &#125;&#125; 泛型实现 这里默认是字符串数组，但是在实际运用时，肯定还有其他类型，所有采用泛型实现，问题就能迎刃而解；12345678910111213141516171819202122/** * @Author fanjiajia * @Date 下午7:50 2018/12/20 * @Description 数组中存在出现次数超过一半的元素，找出来，泛型实现 **/ public &lt;T&gt; T func2(T[] arr) &#123; T candidate = null; int nTimes,i; for (i = nTimes = 0; i &lt; arr.length; i++) &#123; if (nTimes == 0) &#123; candidate = arr[i]; nTimes = 1; &#125;else &#123; if (arr[i] == candidate) nTimes++; else nTimes--; &#125; &#125; return candidate; &#125; 调用123Integer arr[] = &#123;1,2,3,1,2,1&#125;;Demo1 demo1 = new Demo1();System.out.println(demo1.func2(arr)); 衍生问题 数组中存在3个元素，切出现次数超过了数组长度的1/4，求这三个元素 数组中存在1一个元素，出现次数刚好只有数组长度的一半，找出来最后 生命不息，使劲造]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[将Excel表中的数据导入MySQL数据库]]></title>
    <url>%2F2018%2F12%2F18%2Fdatabase%2Fckfv9onrq002eqxlp6llrnv38%2F</url>
    <content type="text"><![CDATA[背景 最近接到交通学院的一个web项目，我的工作是在web页面上做个图表并且定时刷新这个图表，这里使用了Echarts API，关于如何使用，我抽时间再写一篇博客，这里主要记录一下，这个表里面的数据他们提供给我时是一个Excel表，那么我需要将其存储在数据库中，这也给我以启发，我们今后接手项目时，别人给的数据是擦乱无章的，如何整理并结构化存储是我们第一步需要做的。 插曲(Excel表中时间列自增)由于数据库表中有一列是日期+时间，也就是我们所熟悉的yyyy-MM-dd HH:mm:ss，但是她们中Excel只记录了时间，没有日期部分，这里为了造模拟数据，需要添加日期部分。 第一步确定某一个单元格的时间，比如我这里确定了A1单元格的时间，现在想要后面依次增加3秒。 第二步将光标定位到A2上，输入1=TEXT((TEXT(1*A1,&quot;[s]&quot;)+3)/(24*60*60),&quot;e-mm-dd hh:mm:ss&quot;) 注意这里的A1就是确定的起始时间， +3代表加3秒随后向下拖动即可。效果如下： 说正事使用Navicat 导入Excel到MySql数据中这里使用的MySQL界面化工具是Navicat，不多说，直接干。 准备工作，要确定数据库表的字段名和Excel表表头对应一致，如果不一致，后面导入的时候也可自由匹配！比较麻烦，建议提前处理好。 第一步选择Import Wizard 第二步选择Excel文件类型， 亲测其他格式的同样可以！ 第三步Add File，选择需要导入的Excel本地文件 第四步勾选 第五步这里需要选择的是，表头名在哪一行，数据开始是哪一行。我这里是第2行和第3行 第六步选中需要导入数据库哪一张表 第七步将Excel表的表头和数据库表的字段名匹配上，如果数据库表的字段和Excel表的表头不匹配，就需要手动匹配，如果一样，这里会自动匹配。 第八步 选择第一个Append，顾名思义，添加到表中原有数据之后。遇到坑了我一开始导入之后，看到数据库表中有数据了，性喜若狂啊，结果一看我去，为毛我的时间全部都变成了1900-01-20，而我本身时间是2018-09-25啊。开始百度填坑首先将时间列数据库表的数据类型，设置为varchar，随后导入，发现不会有错，然后再改回datetime类型，我发现直接利用工具的Design Table改不行，改了之后还是1990-01-20。我也是运气好，换了一种方式，执行sql语句1ALTER TABLE flow MODIFY time datetime perfect！！！！OK 搞定了。 最后 此致，敬礼]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程练习：1的数目]]></title>
    <url>%2F2018%2F12%2F18%2Fprogramming-practise%2Fckfv9onse0041qxlpfotyf35g%2F</url>
    <content type="text"><![CDATA[题目: 1的数目 来源: 编程之美给定一个十进制正整数N，写下从1开始，到N的所有整数，然后数一下其中出现的所有”1”的个数。例如： N = 2，写下1，2。这样只出现了1个”1”N = 12， 1，2，3，4，5，6，7，8，9，10，11，12。这样1的个数为5； 分析 具体分析见图 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; System.out.println(Sum1s(Long.parseLong(scanner.next()))); &#125; &#125; public static long Sum1s(long n) &#123; long iCount = 0; // long iFactor = 1; // 个十百千万 long iLowerNum = 0; // 低位数字 比如12123，以百位1为界，低位数字为23 int iCurrNum = 0; // 每一位上的数字，取值0-9 long iHigherNum = 0; // 高位数字，类似上面 while (n / iFactor != 0) &#123; iLowerNum = n - (n / iFactor) * iFactor; // 获得高位数字 iCurrNum = (int)(n / iFactor) % 10; // 获得当前位数字 iHigherNum = n / (iFactor * 10); // 获得高位数字 switch (iCurrNum) &#123; case 0 : iCount += iHigherNum * iFactor; // 高位 * 当前位数 break; case 1: iCount += iHigherNum * iFactor + iLowerNum +1; // break; default: iCount += (iHigherNum + 1) * iFactor; break; &#125; iFactor *= 10; &#125; return iCount; &#125;&#125; 此致，敬礼]]></content>
      <categories>
        <category>编程练习</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python+OpenCV实现LBP特征提取]]></title>
    <url>%2F2018%2F12%2F14%2FPython%2Fckfv9onrg001mqxlp1bxa1ufe%2F</url>
    <content type="text"><![CDATA[背景 看了些许的纹理特征提取的paper，想自己实现其中部分算法，看看特征提取之后的效果是怎样 运行环境 Mac OS Python3.0 Anaconda3(集成了很多包，浏览器界面编程，清爽)步骤导入包123456789from skimage.transform import rotatefrom skimage.feature import local_binary_patternfrom skimage import data, io,data_dir,filters, featurefrom skimage.color import label2rgbimport skimageimport numpy as npimport matplotlib.pyplot as pltfrom PIL import Imageimport cv2 参数设置123# settings for LBPradius = 1 # LBP算法中范围半径的取值n_points = 8 * radius # 领域像素点数 图像读取123456# 读取图像image = cv2.imread(&apos;img/logo.png&apos;)#显示到plt中，需要从BGR转化到RGB，若是cv2.imshow(win_name, image)，则不需要转化image1 = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)plt.subplot(111)plt.imshow(image1) 灰度转换123image = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY)plt.subplot(111)plt.imshow(image, plt.cm.gray) LBP处理123lbp = local_binary_pattern(image, n_points, radius)plt.subplot(111)plt.imshow(lbp, plt.cm.gray) 边缘提取123edges = filters.sobel(image)plt.subplot(111)plt.imshow(edges, plt.cm.gray) 此致,敬礼]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android—实现科大讯飞语音合成]]></title>
    <url>%2F2018%2F11%2F23%2FAndroid%2Fckfv9onr2000jqxlpeczoz8sp%2F</url>
    <content type="text"><![CDATA[背景（可以不看） 实验室项目开发的APP需要有语音提示功能，之前的做法是人工录音，剪辑片段，调用Android的多媒体，播放，呵呵呵，，，这是21世纪！这样肯定显得有点low啊，且不说档次，应用场景也不足啊，人工录音内容固定，这不适合我们的需求。其实我当时也不知道这技术叫语音合成,老师提了一提，下来一百度，科大讯飞果断站了出来，提供了API，给你点个赞！这里介绍一下如何使用该API中的语音合成技术。 准备工作注册开发者APPID首先需要做的就是注册能够使用该API的APPID，如今使用这种API都需要注册，比如百度地图API等，不想多说，并向你抛出了个链接 http://www.xfyun.cn 导入SDK注册完APPDID之后，下载开发包，解压缩，得到如下文件，在Android Studio项目结构下的app下新建libs，将其中的文件全部copy到libs下，如下图所示： 这里要注意啊，导进来要进行Gradle的编译啊，并且注意到每一项前面的三角符号是可以点开的，下面有内容的，这是需要编译之后才有，如果不能打开，相当于只是添加了些文件，后面使用里面的类，代码无法自动提示，MB，都没编译进来，有个屁啊，（本人踩过的坑，手动捂脸） 添加用户权限需要配置如下权限12345678910111213141516171819202122232425&lt;!--连接网络权限，用于执行云端语音能力 --&gt;&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&lt;!--获取手机录音机使用权限，听写、识别、语义理解需要用到此权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;&lt;!--读取网络信息状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot;/&gt;&lt;!--获取当前wifi状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_WIFI_STATE&quot;/&gt;&lt;!--允许程序改变网络连接状态 --&gt;&lt;uses-permission android:name=&quot;android.permission.CHANGE_NETWORK_STATE&quot;/&gt;&lt;!--读取手机信息权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;&lt;!--读取联系人权限，上传联系人需要用到此权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;&lt;!--外存储写权限，构建语法需要用到此权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;&lt;!--外存储读权限，构建语法需要用到此权限 --&gt;&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;/&gt;&lt;!--配置权限，用来记录应用配置信息 --&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_SETTINGS&quot;/&gt;&lt;!--手机定位信息，用来为语义等功能提供定位，提供更精准的服务--&gt;&lt;!--定位信息是敏感信息，可通过Setting.setLocationEnable(false)关闭定位请求 --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;&lt;!--如需使用人脸识别，还要添加：摄相头权限，拍照需要用到 --&gt;&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; 配置Gradle使用AS开发Android Application Gradle的配置少不了，官方的文档上没有指出需要配置Gradle，但是事实证明不配置的话，会出现一个很奇怪的异常，在Module下的build.gradle文件： 在defaultConfig下添加以下内容:1234567// 配置.so文件 ndk &#123; // 选择要添加的对应的cpu类型的.so库 abiFilters &apos;x86&apos;, &apos;armeabi&apos;, &apos;armeabi-v7a&apos;, &apos;armeabi-v8a&apos;, &apos;mips&apos;,&apos;mips64&apos;,&apos;x86_64&apos; &#125;``` 2. 在`buildTypes`下添加以下内容： //配置JNILibs sourceSets { main { jniLibs.srcDirs = [‘libs’] } }12345### 到这里，准备工作应该是准备完成了### 干正事#### SDK的初始化初始化就一句话 // 进行SDK的初始化SpeechUtility.createUtility(APP.this, SpeechConstant.APPID + “=yourAPPID”);12345678910这句话一般写在app初始化时，如果你是写demo，只有一个Activity，那么就写在onCreate之后就可以，但是我相信，真正使用绝非这么简单，所以配置到APP文件中最好，我一开始不知道什么是APP文件(手动捂脸，好low)，其实APP文件是一个java类文件，继承Application，如下图：![](https://i.loli.net/2018/11/23/5bf7e1b0c646b.png)Application这个类，一看就应该明了，是我们每个应用程序都用的，然后如何将我们新建的APP和我们的Android程序关联，看下图：![](https://i.loli.net/2018/11/23/5bf7e1aedf813.png)这是`AndroidManifest.xml` 下的配置项，将这里的application指定为我们自己创建的java类文件即可，看到`.APP`前面的那一个`.`点没有，表示路径，说明我们的APP.java类直接在我们的包名下。如下图：![](https://i.loli.net/2018/11/23/5bf7e1b361f4b.png)这里`com.jiajia.speechdemo`就是我的包名。#### 封装语音合成工具类在上面的截图中有一个TTSUtility类，没错，我们把语音合成疯转在一个工具类中。同时将其打造成单例模式。这样在我们整个应用程序中，只有一个工具类，就不用每次需要合成是都new一个对象 public class TTSUtility { // 发音人 public final static String[] COLOUD_VOICERS_VALUE = {“xiaoyan”, “xiaoyu”, “catherine”, “henry”, “vimary”, “vixy”, “xiaoqi”, “vixf”, “xiaomei”,”xiaolin”, “xiaorong”, “xiaoqian”, “xiaokun”, “xiaoqiang”, “vixying”, “xiaoxin”, “nannan”, “vils”,}; private static final String TAG = &quot;TTSUtility&quot;; // 语音合成对象 private static SpeechSynthesizer mTts; //上下文 private Context mContext; private volatile static TTSUtility instance; /** * 合成回掉监听 */ private static SynthesizerListener mTtsListener = new SynthesizerListener() { @Override public void onSpeakBegin() { Log.d(TAG, &quot;开始播放&quot;); } @Override public void onBufferProgress(int percent, int beginPos, int endPos, String info) { // TODO 缓冲的进度 Log.d(TAG, &quot;缓冲 : &quot; + percent); } @Override public void onSpeakPaused() { Log.d(TAG, &quot;暂停播放&quot;); } @Override public void onSpeakResumed() { Log.d(TAG, &quot;继续播放&quot;); } @Override public void onSpeakProgress(int percent, int beginPos, int endPos) { // TODO 说话的进度 Log.d(TAG, &quot;合成 : &quot; + percent); } @Override public void onCompleted(SpeechError error) { if (error == null) { Log.d(TAG, &quot;播放完成&quot;); } else if (error != null) { Log.d(TAG, error.getPlainDescription(true)); } } @Override public void onEvent(int eventType, int arg1, int arg2, Bundle obj) { } }; /** * 构造方法 * * @param context 上下文 */ private TTSUtility(Context context) { mContext = context; // 初始化合成对象 mTts = SpeechSynthesizer.createSynthesizer(mContext, new InitListener() { @Override public void onInit(int code) { if (code != ErrorCode.SUCCESS) { Log.d(&quot;fjj&quot;, &quot;初始化失败,错误码：&quot; + code); } Log.d(&quot;fjj&quot;, &quot;初始化失败,q错误码：&quot; + code); } }); } public static TTSUtility getInstance(Context context) { if (instance == null) { synchronized (TTSUtility.class) { if (instance == null) { instance = new TTSUtility(context); } } } return instance; } /** * 停止语音播报 */ public static void stopSpeaking() { // 对象非空并且正在说话 if (null != mTts &amp;&amp; mTts.isSpeaking()) { // 停止说话 mTts.stopSpeaking(); } } /** * 判断当前有没有说话 * * @return */ public static boolean isSpeaking() { if (null != mTts) { return mTts.isSpeaking(); } else { return false; } } /** * 开始合成 * * @param text */ public void speaking(String text) { if (TextUtils.isEmpty(text)) return; int code = mTts.startSpeaking(text, mTtsListener); Log.d(&quot;fjj&quot;, &quot;-----&quot; + code + &quot;++++++++++&quot;); if (code != ErrorCode.SUCCESS) { if (code == ErrorCode.ERROR_COMPONENT_NOT_INSTALLED) { Toast.makeText(mContext, &quot;没有安装语音+ code = &quot; + code, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(mContext, &quot;语音合成失败,错误码: &quot; + code, Toast.LENGTH_SHORT).show(); } } } /** * 参数设置 * * @return */ private void setParam() { // 清空参数 mTts.setParameter(SpeechConstant.PARAMS, null); // 引擎类型 网络 mTts.setParameter(SpeechConstant.ENGINE_TYPE, SpeechConstant.TYPE_CLOUD); // 设置发音人 mTts.setParameter(SpeechConstant.VOICE_NAME, COLOUD_VOICERS_VALUE[0]); // 设置语速 mTts.setParameter(SpeechConstant.SPEED, &quot;50&quot;); // 设置音调 mTts.setParameter(SpeechConstant.PITCH, &quot;50&quot;); // 设置音量 mTts.setParameter(SpeechConstant.VOLUME, &quot;100&quot;); // 设置播放器音频流类型 mTts.setParameter(SpeechConstant.STREAM_TYPE, &quot;3&quot;); // mTts.setParameter(SpeechConstant.TTS_AUDIO_PATH, Environment.getExternalStorageDirectory() + &quot;/KRobot/wavaudio.pcm&quot;); // 背景音乐 1有 0 无 // mTts.setParameter(&quot;bgs&quot;, &quot;1&quot;); } }12这样封装之后在任何你想要&quot;说话&quot;的地方直接调用下面者句话就可以； TTSUtility.getInstance(getApplicationContext()).speaking(“编程使我快乐”);` 可以看到封装的工具类中可以进行参数的设置，主要包括以下内容：语言（LANGUAGE，中文、英文等）方言（ACCENT，中文的普通话，粤语等）发音人特征（性别，年龄，语气）语速（SPEED）音量（VOLUME）语调（PITCH）音频采样率（SAMPLE_RATE） 感兴趣可以自己多尝试！ 本人菜鸟程序猿一枚，如有错误，请指出，Thanks！ 参考资料 科大讯飞开发指南 科大讯飞在线语音合成（2018最新版本) 最后 此致，敬礼]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Could not resolve com.android.support.constraint:constraint-layout:1.1.3.]]></title>
    <url>%2F2018%2F11%2F23%2FAndroid%2Fckfv9onqu0008qxlpoj2mzt6e%2F</url>
    <content type="text"><![CDATA[背景 很久没有新建Android项目，今天想新建一个项目然后学习一下模块依赖，刚新建的项目居然提示gradle编译不通过，搞笑！ 错误再现新建项目，报错如下： 意思就是无法依赖constraint-layout:1.1.3 解决方法打开Android Studio的设置，在Appearance &amp; Behavior -&gt; System Setting -&gt; Android SDK下查看SDK Tools，这里注意勾选右下角的show package detail查看你安装的ConstraintLayout是什么版本。我这里是1.0.2，而查看我app的build.gradle中的配置，对没错就是1.1.3这就很好解决了，将这里改成1.0.2即可。 注意：有时会发现没有安装相应的版本，如果有你需要的版本，勾选安装即可。 最后 此致，敬礼]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上利用Aria2加速百度网盘下载]]></title>
    <url>%2F2018%2F11%2F23%2Fkits%2Fckfv9onrd001dqxlpjmtrreid%2F</url>
    <content type="text"><![CDATA[百度网盘下载东西的速度那叫一个慢，特别是大文件，看着所需时间几个小时以上，让人很不舒服，本文记录自己在mac上利用工具Aria2加速的教程，windows下思路也是一样！ 科普(可以不看) 这里顺带科普一下，有时候我们上传一个大文件，会发现是秒传，特别是某些电影，其实很简单，百度网盘做了优化，所有上传的资源会处理成一个串（网络安全课上老师提到过，具体什么东西也没深究），当用户上传资源时，会进行对比，如果存在，就不会实际上传你的物理资源，不信，你可以自己拍一段视频，第一次上传，然后再一次上传，会发现第二次秒传！ 正文不多说，并向你抛出两个下载链接: Aria2工具下载 https://github.com/yangshun1029/aria2gui/releases 打开后下载最新的Aria2工具，安装。 插件下载链接:https://pan.baidu.com/s/12I5FuMQKqrUjXD4zM2EBsA 密码: lb25插件下包括如下三个文件: 这三个插件都是Chorme浏览器的扩展程序，如何添加扩展程序就不多说了，但是注意添加方式不同，chrome文件夹和YAAM的添加一样，直接选择加载已解压的扩展程序即可，但是BaiduExporter插件的安装不同，该文件下有如下内容:看到BaiduExporter.crx没有，对，这就是扩展程序文件，直接在chorme扩展程序网页，将该文件拖进去即可 到这里就完成了安装，随便找个百度网盘分享，看到上面有导出下载，选择什么不说了吧。 注意在下载时一定要打开你的Aria2软件啊。废话，不打开的话，怎么下载！ PS 如果发现无法下载，（本人就是），此时需要进行简单的配置一下，打开Aria2软件的显示包含内容，找到如下文件Contens-&gt;Resources—&gt;aria2.conf , 在该文件末尾加上check-certificate=false 知其然，要知其所以然（可以不看了） Aria2之所以能够加快下载速度，因为他是多线程的方式，好像这句话并没有什么实质性的解释哈！ 我们安装了这么多的插件，都是干嘛的呢，首先来说一下，压缩文件中的chrome文件，这是百度网盘助手，这个扩展程序就能够在上图那里出现导出下载选项。他主要将我们的下载导入到Aria2里面下载。 YAAM这个插件能够在我们的Chrome浏览器中管理Aria2的下载任务。点击右上角扩展程序图标，便会出现和Aria2软件一样的界面，可以在这里管理。 那BaiduExporter又是个什么鬼呢，有时候某些很大的文件，上面百度网盘助手并不能够将其下载导入到Aria2中，此时就需要该插件，安装完此插件，见下图效果:会在我们的百度网盘处出现这样的导出下载选项，我们可以在这里进行导出Aria2下载。 参考资料 Aria2GUI YAAM BaiduExporter 最后 此致，敬礼]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 添加模块依赖]]></title>
    <url>%2F2018%2F11%2F23%2Fandroidstudio%2Fckfv9onqv0009qxlpmtfu50so%2F</url>
    <content type="text"><![CDATA[通常我们依赖第三方的一些库时，在AS中都是通过gradle配置导入，对于这种方式的变形，我们通常只能看源码，而不能在此基础上进行修改，因此将源码下载到项目中，编译为库，添加到项目依赖中，方便我们对某些库进行一些改动。 步骤 第一步 右键项目-&gt; New-&gt;Module 第二步 选择Android Library 第三步 为你的库取一个名字 第四步 将源码中的src-&gt;libs-&gt;build.gradle 复制到新建的Library下，选择OverWrite for all 第五步 File-&gt;Project Structure app-&gt;Dependencies, 选中+号，添加Module dependency, 选择你刚新建的Library 第六步 查看app的build.gradle，会发现多了这一行。搞定最后 此致， 敬礼]]></content>
      <categories>
        <category>Android Studio</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上基于hexo+GitHub搭建个人博客(一)]]></title>
    <url>%2F2018%2F11%2F23%2Fkits%2Fckfv9onrb0016qxlp9of21guq%2F</url>
    <content type="text"><![CDATA[之前一直使用博客园和简书，但是博客园太复杂，而简书虽然很简单，但是没什么新鲜感，偶然得知hexo+github可以搭建自己的博客，主要是可以自己定主题，还很simple，因此，找了个时间，自己搞了一下，感觉还可以，就自己弄了一个。 环境配置Hexo官网上有搭建文档！ 安装Node.jsNode.js是一个Javascript运行环境,用来生成静态界面，到Node.js官网上下载相应的版本即可，我搭建时v8.11.1 LTS，傻瓜式一路安装！ Gitmac系统自带Git 安装Hexo安装Hexo当前两步准备好了之后，就可以使用命令安装了，打开终端输入命令:1$ sudo npm install -g hexo 这个地方一开始出现rollbackFailedOptional，好像是什么Failed，正当我去百度的时候，再回头，居然在开始安装了，懵逼！ 本地初始化操作 cd 到你想安装的目录，比如我选的Documents下，执行hexo init命令1$ hexo init iblog iblog 是我建立的文件夹名称，cd到iblog文件夹下，执行安装npm 命令:1$ npm install 开启hexo服务器:1$ hexo s 此时终端出现指示我们的服务器已经开始跑起来了，在浏览器中输入网址:http://localhost:4000/即可看到如下界面此时说明本地已经设置好了！，接下来开始关联GitHub。 关联Github首先New repository 以下，创建一个新的仓库，注意仓库名称为固定写法用户名.github.io,比如我的为Numen-fan.github.io,如下图所示：创建完成后为：同时本地iblog文件夹下有如下内容: cd到iblog下面，vim打开_config.yml文件，1$ vim _config.yml 打开后翻倒最后面修改为如下样式(我是用submit打开的)：1234deploy: type: git repository: https://github.com/Numen-fan/Numen-fan.github.io.git branch: master 注意这里的链接是创建仓库时生成的，为了手写错误，最好从创建出copy过来 同时注意这里的:后一定需要空格(切记) 在iblog下执行如下命令，用来生成静态的页面1$ hexo g 网上说这里可能报错 ERROR Local hexo not found in ~/blogERROR Try runing: ‘npm install hexo –save’ 我似乎没有，蛮幸运。 解决办法是12$ npm install hexo --save&gt; 然后再开始配置，执行以下命令1$ hexo d 这个地方我报错了，提示无法链接到gi或找不到git，解决办法是需要安装hexo-deployer-git1$ npm install hexo-deployer-git --save 这个时候弹出: 这个地方需要输入的是电脑的登录密码，我一开始以为是Github的账号密码了(懵逼) 可以选拒绝，随后需要输入以下两项：12Username for GitHub:Password for GitHub: 后面配置了SSH之后，就可以不用每次输入了； 然后再次执行hexo g 和 hexo d 执行成功后，浏览器输入https://Numen-fan.github.io（将Numen-fan改为自己的Github用户名即可），此时就能看到刚才和本地`http://localhost:4000`一样的界面了 注意这里如果你没有做SSH key的关联，在hexo d 时是需要你输入github的用户名和密码的。我之前做了关联，所有没有提示，每次都需要输入密码很烦，所以请参考配置SSH Key到GitHub 此致，敬礼]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[阅读—黑客与画家]]></title>
    <url>%2F2018%2F11%2F22%2Fpetty%2Fckfv9onqt0005qxlpn5uuj5tw%2F</url>
    <content type="text"><![CDATA[每每读完一本书，心中总是一团乱，思绪纷繁，很难寻求出一条线索，能够贯穿全书，也很难从中领悟出哲学道理和生活真谛，然后交给文字娓娓道来。或许读书本不该有如此心态，享受的是阅读时，内心的那份恬静和淡然，像一个与世无争的隐者。从来不是为了读书而读书，所以，也不是想写下大道理，仅有拙见！ 黑客(hacker)，起初代表的是优秀的程序员，通常是专家级程序员。当今指那些专门侵入别人电脑的程序员，我认为作为行内人，我们对黑客不能投以憎恶的眼光。黑客的工作同建筑师、画家、作家一样都是创作者，他们的创作很简单，一台电脑即可，同时黑客创造财富的方式也很简单，一部电脑即可（财富不等同于金钱）。 以用户为导向，设计出优秀的产品，永远坚信“用户永远是对的”，但是用户是针对性的，比如初级用户，专家用户，这就涉及到产品定位。 程序员，快速致富的方式1 创业， 2 去创业公司，但是二者都必须要承担相应的风险。 优秀的程序员可以带来增益，然而平庸的程序员只会带来麻烦，比如引入bug。 软件开发团队人数不应过多，必须层次分明。 永远不要对上司说，这块不是我做的，言外之意就是这个问题不是我带来的。作为参与者，你对这个问题没有责任，但是有义务。 过早的优化永远是万恶之源，好比画家画一块砖头，一开始就专注细节，画到一半厌倦了，放弃了，这幅画注定是失败的，但是如果一开始有一个轮廓，最后的成果至少有雏形，不会不伦不类。所以软件最好要有原型（prototype），原型不等于模型（model）。 掌握小群体语言，你就掌握了独特的优势。 了解一个公司永远不要看宣传，看招聘的岗位和使用的语言就行。 此致，敬礼]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>读后感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python-爬取"我去图书馆"座位编码]]></title>
    <url>%2F2018%2F11%2F22%2FPython%2Fckfv9onri001tqxlpgurtczdp%2F</url>
    <content type="text"><![CDATA[背景 曾几何时，去图书馆都是在终端上拿校园卡刷，这就意味着，人必须去，当然啦也有拿着卡代刷的，确实不妥。很久没去过图书馆了，现在的图书馆都采用微信工作号“我去图书馆”，在上面进行预约，然后在预约后规定时间里去图书馆终端上刷码，同时也可以进行明日预约，这个功能能够让很多人不用担心明天早起排队，然后看似很棒的东西，居然出现刷坐程序，特别是明日预约，瞬间被预约完成，有点恶心，但是还是那句话，技术本身是无罪的，有”罪”的是使用的人。这不一个同学介绍了一个同学，他拿到了刷票程序，python实现，但祖传自南京某大学，不适用whut啊，因此我好好的看了一下，然后首先要解决的就是获取微信的sessionID,这个已经可以通过抓包实现，见https://fanjiajia.cn/2018/11/21/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8Charles%E6%8A%93%E5%8C%85Android/然后就是要获取图书馆的位置编码，也就是如何给图书馆的位置变号的。 爬取位置页面首先肯定是要获取位置页面的html，同上抓包工具，抓到了url，But这个链接不能在浏览器中直接打开，浏览器会提示说请用微信客户端打开，如果在爬虫程序中直接使用request，那么封装的Header肯定指定的发起浏览器需要和微信使用的一直。那怎么办呢，不着急，在抓包中，直接获取Text，这就是返回的html文本，copy出来，存在本地，然后读取本地文件进行解析。 截取html文件中的位置绘制部分如下：123456789101112131415161718192021&lt;div class=&quot;grid_cell grid_1&quot; data-key=&quot;5,7&quot; style=&quot;left:280px;top:210px;&quot;&gt; &lt;em&gt;3&lt;/em&gt; &lt;/div&gt; &lt;div class=&quot;grid_cell grid_active&quot; data-key=&quot;5,8&quot; style=&quot;left:315px;top:210px;&quot;&gt; &lt;em&gt;2&lt;/em&gt; &lt;/div&gt; &lt;div class=&quot;grid_cell grid_8&quot; data-key=&quot;5,11&quot; style=&quot;left:420px;top:210px;&quot;&gt; &lt;em&gt;&lt;/em&gt; &lt;/div&gt; &lt;div class=&quot;grid_cell grid_8&quot; data-key=&quot;5,12&quot; style=&quot;left:455px;top:210px;&quot;&gt; &lt;em&gt;&lt;/em&gt; &lt;/div&gt; &lt;div class=&quot;grid_cell grid_8&quot; data-key=&quot;5,13&quot; style=&quot;left:490px;top:210px;&quot;&gt; &lt;em&gt;&lt;/em&gt; &lt;/div&gt; &lt;div class=&quot;grid_cell grid_8&quot; data-key=&quot;5,14&quot; style=&quot;left:525px;top:210px;&quot;&gt; &lt;em&gt;&lt;/em&gt; &lt;/div&gt; &lt;div class=&quot;grid_cell grid_active&quot; data-key=&quot;5,17&quot; style=&quot;left:630px;top:210px;&quot;&gt; &lt;em&gt;29&lt;/em&gt; &lt;/div&gt; 分析上面的代码，看见一个div就是一个位置，位置的编号就是em的文本内容，我们主要是需要这个位置data-key页面解析上面的代码已经很清楚了，需要获取em标签文本不为空时的父表情的data-key属性。 第一步：导入需要的库，1from bs4 import BeautifulSoup 这里只需要用BeautifulSoup来解析即可。 第二步: 定义获取一个房间(一个html)的位置12345678910def getOneRoomSeats(url): with open(url,&apos;r&apos;) as wb_data: soup = BeautifulSoup(wb_data,&apos;lxml&apos;) # print(Soup.prettify()) seats = &#123;&#125; for tag in soup.find_all(&apos;em&apos;): # for循环遍历所有a标签，并把返回列表中的内容赋给t if tag.string != None: seats[tag.string] = tag.parent.get(&apos;data-key&apos;) return seats 这里采用字典的方式进行存储，比如{&#39;29&#39;:&#39;5,17&#39;}，就代表29号座的信息，那么最后一个房间的所有座位都变成了这样的字典形式。 第三步: 获取所有房间的位置信息12345678def getAllRoomSeats(urls): AllLibSeats = &#123;&#125; a = 1 for url in urls: seats = getOneRoomSeats(url) AllLibSeats[a] = seats a = a + 1 return AllLibSeats urls是一个列表，表示上面所爬取的存在本地的所有文件路径。最后用一个字典存储所有的房间位置信息。 最后 好了，这样就把所有的位置信息获取到了，这里，我就把我们学校WHUT的图书馆在”我去图书馆”的位置信息送上吧，虽然我看的那个刷坐程序现在似乎已经不行了，因为给任何一个结尾的url返回的都是预约成功。 1234567891011R1_SEATTABLE=&#123;&apos;3&apos;: &apos;5,7&apos;, &apos;2&apos;: &apos;5,8&apos;, &apos;29&apos;: &apos;5,17&apos;, &apos;30&apos;: &apos;5,18&apos;, &apos;4&apos;: &apos;7,7&apos;, &apos;1&apos;: &apos;7,8&apos;, &apos;31&apos;: &apos;7,17&apos;, &apos;32&apos;: &apos;7,18&apos;, &apos;5&apos;: &apos;9,7&apos;, &apos;6&apos;: &apos;9,8&apos;, &apos;7&apos;: &apos;11,7&apos;, &apos;8&apos;: &apos;11,8&apos;, &apos;10&apos;: &apos;13,7&apos;, &apos;9&apos;: &apos;13,8&apos;, &apos;33&apos;: &apos;13,17&apos;, &apos;34&apos;: &apos;13,18&apos;, &apos;11&apos;: &apos;15,7&apos;, &apos;12&apos;: &apos;15,8&apos;, &apos;35&apos;: &apos;15,17&apos;, &apos;36&apos;: &apos;15,18&apos;, &apos;13&apos;: &apos;17,7&apos;, &apos;14&apos;: &apos;17,8&apos;, &apos;37&apos;: &apos;17,17&apos;, &apos;38&apos;: &apos;17,18&apos;, &apos;15&apos;: &apos;19,7&apos;, &apos;16&apos;: &apos;19,8&apos;, &apos;39&apos;: &apos;19,17&apos;, &apos;40&apos;: &apos;19,18&apos;, &apos;17&apos;: &apos;21,7&apos;, &apos;18&apos;: &apos;21,8&apos;, &apos;41&apos;: &apos;21,17&apos;, &apos;42&apos;: &apos;21,18&apos;, &apos;19&apos;: &apos;23,7&apos;, &apos;20&apos;: &apos;23,8&apos;, &apos;43&apos;: &apos;23,17&apos;, &apos;44&apos;: &apos;23,18&apos;, &apos;21&apos;: &apos;25,7&apos;, &apos;22&apos;: &apos;25,8&apos;, &apos;23&apos;: &apos;27,7&apos;, &apos;24&apos;: &apos;27,8&apos;, &apos;25&apos;: &apos;29,7&apos;, &apos;26&apos;: &apos;29,8&apos;, &apos;45&apos;: &apos;29,17&apos;, &apos;46&apos;: &apos;29,18&apos;, &apos;27&apos;: &apos;31,7&apos;, &apos;28&apos;: &apos;31,8&apos;, &apos;47&apos;: &apos;31,17&apos;, &apos;48&apos;: &apos;31,18&apos;&#125; # 二楼（电子阅览室） R2_SEATTABLE=&#123;&apos;32&apos;: &apos;5,11&apos;, &apos;33&apos;: &apos;5,12&apos;, &apos;26&apos;: &apos;5,17&apos;, &apos;27&apos;: &apos;5,18&apos;, &apos;31&apos;: &apos;6,10&apos;, &apos;34&apos;: &apos;6,13&apos;, &apos;25&apos;: &apos;6,16&apos;, &apos;28&apos;: &apos;6,19&apos;, &apos;36&apos;: &apos;7,11&apos;, &apos;35&apos;: &apos;7,12&apos;, &apos;30&apos;: &apos;7,17&apos;, &apos;29&apos;: &apos;7,18&apos;, &apos;38&apos;: &apos;9,11&apos;, &apos;39&apos;: &apos;9,12&apos;, &apos;20&apos;: &apos;9,17&apos;, &apos;21&apos;: &apos;9,18&apos;, &apos;37&apos;: &apos;10,10&apos;, &apos;40&apos;: &apos;10,13&apos;, &apos;19&apos;: &apos;10,16&apos;, &apos;22&apos;: &apos;10,19&apos;, &apos;42&apos;: &apos;11,11&apos;, &apos;41&apos;: &apos;11,12&apos;, &apos;24&apos;: &apos;11,17&apos;, &apos;23&apos;: &apos;11,18&apos;, &apos;44&apos;: &apos;13,11&apos;, &apos;45&apos;: &apos;13,12&apos;, &apos;14&apos;: &apos;13,17&apos;, &apos;15&apos;: &apos;13,18&apos;, &apos;43&apos;: &apos;14,10&apos;, &apos;46&apos;: &apos;14,13&apos;, &apos;13&apos;: &apos;14,16&apos;, &apos;16&apos;: &apos;14,19&apos;, &apos;48&apos;: &apos;15,11&apos;, &apos;47&apos;: &apos;15,12&apos;, &apos;18&apos;: &apos;15,17&apos;, &apos;17&apos;: &apos;15,18&apos;, &apos;50&apos;: &apos;17,11&apos;, &apos;51&apos;: &apos;17,12&apos;, &apos;8&apos;: &apos;17,17&apos;, &apos;9&apos;: &apos;17,18&apos;, &apos;49&apos;: &apos;18,10&apos;, &apos;52&apos;: &apos;18,13&apos;, &apos;7&apos;: &apos;18,16&apos;, &apos;10&apos;: &apos;18,19&apos;, &apos;54&apos;: &apos;19,11&apos;, &apos;53&apos;: &apos;19,12&apos;, &apos;12&apos;: &apos;19,17&apos;, &apos;11&apos;: &apos;19,18&apos;, &apos;56&apos;: &apos;21,11&apos;, &apos;57&apos;: &apos;21,12&apos;, &apos;2&apos;: &apos;21,17&apos;, &apos;3&apos;: &apos;21,18&apos;, &apos;55&apos;: &apos;22,10&apos;, &apos;58&apos;: &apos;22,13&apos;, &apos;1&apos;: &apos;22,16&apos;, &apos;4&apos;: &apos;22,19&apos;, &apos;60&apos;: &apos;23,11&apos;, &apos;59&apos;: &apos;23,12&apos;, &apos;6&apos;: &apos;23,17&apos;, &apos;5&apos;: &apos;23,18&apos;&#125; # 三楼 R3_SEATTABLE=&#123;&apos;1&apos;: &apos;5,8&apos;, &apos;2&apos;: &apos;5,9&apos;, &apos;5&apos;: &apos;5,11&apos;, &apos;6&apos;: &apos;5,12&apos;, &apos;9&apos;: &apos;5,14&apos;, &apos;10&apos;: &apos;5,15&apos;, &apos;3&apos;: &apos;7,8&apos;, &apos;4&apos;: &apos;7,9&apos;, &apos;7&apos;: &apos;7,11&apos;, &apos;8&apos;: &apos;7,12&apos;, &apos;11&apos;: &apos;7,14&apos;, &apos;12&apos;: &apos;7,15&apos;, &apos;13&apos;: &apos;9,8&apos;, &apos;14&apos;: &apos;9,9&apos;, &apos;17&apos;: &apos;9,11&apos;, &apos;18&apos;: &apos;9,12&apos;, &apos;21&apos;: &apos;9,14&apos;, &apos;22&apos;: &apos;9,15&apos;, &apos;15&apos;: &apos;11,8&apos;, &apos;16&apos;: &apos;11,9&apos;, &apos;19&apos;: &apos;11,11&apos;, &apos;20&apos;: &apos;11,12&apos;, &apos;23&apos;: &apos;11,14&apos;, &apos;24&apos;: &apos;11,15&apos;, &apos;25&apos;: &apos;13,8&apos;, &apos;26&apos;: &apos;13,9&apos;, &apos;29&apos;: &apos;13,11&apos;, &apos;30&apos;: &apos;13,12&apos;, &apos;33&apos;: &apos;13,14&apos;, &apos;34&apos;: &apos;13,15&apos;, &apos;27&apos;: &apos;15,8&apos;, &apos;28&apos;: &apos;15,9&apos;, &apos;31&apos;: &apos;15,11&apos;, &apos;32&apos;: &apos;15,12&apos;, &apos;35&apos;: &apos;15,14&apos;, &apos;36&apos;: &apos;15,15&apos;, &apos;37&apos;: &apos;17,8&apos;, &apos;38&apos;: &apos;17,9&apos;, &apos;41&apos;: &apos;17,11&apos;, &apos;42&apos;: &apos;17,12&apos;, &apos;45&apos;: &apos;17,14&apos;, &apos;46&apos;: &apos;17,15&apos;, &apos;39&apos;: &apos;19,8&apos;, &apos;40&apos;: &apos;19,9&apos;, &apos;43&apos;: &apos;19,11&apos;, &apos;44&apos;: &apos;19,12&apos;, &apos;47&apos;: &apos;19,14&apos;, &apos;48&apos;: &apos;19,15&apos;, &apos;49&apos;: &apos;21,8&apos;, &apos;50&apos;: &apos;21,9&apos;, &apos;53&apos;: &apos;21,11&apos;, &apos;54&apos;: &apos;21,12&apos;, &apos;57&apos;: &apos;21,14&apos;, &apos;58&apos;: &apos;21,15&apos;, &apos;51&apos;: &apos;23,8&apos;, &apos;52&apos;: &apos;23,9&apos;, &apos;55&apos;: &apos;23,11&apos;, &apos;56&apos;: &apos;23,12&apos;, &apos;59&apos;: &apos;23,14&apos;, &apos;60&apos;: &apos;23,15&apos;, &apos;61&apos;: &apos;25,8&apos;, &apos;62&apos;: &apos;25,9&apos;, &apos;65&apos;: &apos;25,11&apos;, &apos;66&apos;: &apos;25,12&apos;, &apos;69&apos;: &apos;25,14&apos;, &apos;70&apos;: &apos;25,15&apos;, &apos;63&apos;: &apos;27,8&apos;, &apos;64&apos;: &apos;27,9&apos;, &apos;67&apos;: &apos;27,11&apos;, &apos;68&apos;: &apos;27,12&apos;, &apos;71&apos;: &apos;27,14&apos;, &apos;72&apos;: &apos;27,15&apos;, &apos;73&apos;: &apos;29,8&apos;, &apos;74&apos;: &apos;29,9&apos;, &apos;77&apos;: &apos;29,11&apos;, &apos;78&apos;: &apos;29,12&apos;, &apos;81&apos;: &apos;29,14&apos;, &apos;82&apos;: &apos;29,15&apos;, &apos;75&apos;: &apos;31,8&apos;, &apos;76&apos;: &apos;31,9&apos;, &apos;79&apos;: &apos;31,11&apos;, &apos;80&apos;: &apos;31,12&apos;, &apos;83&apos;: &apos;31,14&apos;, &apos;84&apos;: &apos;31,15&apos;, &apos;85&apos;: &apos;33,8&apos;, &apos;86&apos;: &apos;33,9&apos;, &apos;89&apos;: &apos;33,11&apos;, &apos;90&apos;: &apos;33,12&apos;, &apos;93&apos;: &apos;33,14&apos;, &apos;94&apos;: &apos;33,15&apos;, &apos;87&apos;: &apos;35,8&apos;, &apos;88&apos;: &apos;35,9&apos;, &apos;91&apos;: &apos;35,11&apos;, &apos;92&apos;: &apos;35,12&apos;, &apos;95&apos;: &apos;35,14&apos;, &apos;96&apos;: &apos;35,15&apos;, &apos;97&apos;: &apos;37,8&apos;, &apos;98&apos;: &apos;37,9&apos;, &apos;101&apos;: &apos;37,11&apos;, &apos;102&apos;: &apos;37,12&apos;, &apos;105&apos;: &apos;37,14&apos;, &apos;106&apos;: &apos;37,15&apos;, &apos;99&apos;: &apos;39,8&apos;, &apos;100&apos;: &apos;39,9&apos;, &apos;103&apos;: &apos;39,11&apos;, &apos;104&apos;: &apos;39,12&apos;, &apos;107&apos;: &apos;39,14&apos;, &apos;108&apos;: &apos;39,15&apos;, &apos;109&apos;: &apos;41,8&apos;, &apos;110&apos;: &apos;41,9&apos;, &apos;113&apos;: &apos;41,11&apos;, &apos;114&apos;: &apos;41,12&apos;, &apos;117&apos;: &apos;41,14&apos;, &apos;118&apos;: &apos;41,15&apos;, &apos;111&apos;: &apos;43,8&apos;, &apos;112&apos;: &apos;43,9&apos;, &apos;115&apos;: &apos;43,11&apos;, &apos;116&apos;: &apos;43,12&apos;, &apos;119&apos;: &apos;43,14&apos;, &apos;120&apos;: &apos;43,15&apos;&#125; # 四楼 R4_SEATTABLE=&#123;&apos;1&apos;: &apos;5,8&apos;, &apos;2&apos;: &apos;5,9&apos;, &apos;5&apos;: &apos;5,12&apos;, &apos;6&apos;: &apos;5,13&apos;, &apos;9&apos;: &apos;5,16&apos;, &apos;10&apos;: &apos;5,17&apos;, &apos;3&apos;: &apos;7,8&apos;, &apos;4&apos;: &apos;7,9&apos;, &apos;7&apos;: &apos;7,12&apos;, &apos;8&apos;: &apos;7,13&apos;, &apos;11&apos;: &apos;7,16&apos;, &apos;12&apos;: &apos;7,17&apos;, &apos;13&apos;: &apos;9,8&apos;, &apos;14&apos;: &apos;9,9&apos;, &apos;17&apos;: &apos;9,12&apos;, &apos;18&apos;: &apos;9,13&apos;, &apos;21&apos;: &apos;9,16&apos;, &apos;22&apos;: &apos;9,17&apos;, &apos;15&apos;: &apos;11,8&apos;, &apos;16&apos;: &apos;11,9&apos;, &apos;19&apos;: &apos;11,12&apos;, &apos;20&apos;: &apos;11,13&apos;, &apos;23&apos;: &apos;11,16&apos;, &apos;24&apos;: &apos;11,17&apos;, &apos;25&apos;: &apos;13,8&apos;, &apos;26&apos;: &apos;13,9&apos;, &apos;29&apos;: &apos;13,12&apos;, &apos;30&apos;: &apos;13,13&apos;, &apos;33&apos;: &apos;13,16&apos;, &apos;34&apos;: &apos;13,17&apos;, &apos;27&apos;: &apos;15,8&apos;, &apos;28&apos;: &apos;15,9&apos;, &apos;31&apos;: &apos;15,12&apos;, &apos;32&apos;: &apos;15,13&apos;, &apos;35&apos;: &apos;15,16&apos;, &apos;36&apos;: &apos;15,17&apos;, &apos;37&apos;: &apos;17,8&apos;, &apos;38&apos;: &apos;17,9&apos;, &apos;41&apos;: &apos;17,12&apos;, &apos;42&apos;: &apos;17,13&apos;, &apos;45&apos;: &apos;17,16&apos;, &apos;46&apos;: &apos;17,17&apos;, &apos;39&apos;: &apos;19,8&apos;, &apos;40&apos;: &apos;19,9&apos;, &apos;43&apos;: &apos;19,12&apos;, &apos;44&apos;: &apos;19,13&apos;, &apos;47&apos;: &apos;19,16&apos;, &apos;48&apos;: &apos;19,17&apos;, &apos;49&apos;: &apos;21,8&apos;, &apos;50&apos;: &apos;21,9&apos;, &apos;53&apos;: &apos;21,12&apos;, &apos;54&apos;: &apos;21,13&apos;, &apos;57&apos;: &apos;21,16&apos;, &apos;58&apos;: &apos;21,17&apos;, &apos;51&apos;: &apos;23,8&apos;, &apos;52&apos;: &apos;23,9&apos;, &apos;55&apos;: &apos;23,12&apos;, &apos;56&apos;: &apos;23,13&apos;, &apos;59&apos;: &apos;23,16&apos;, &apos;60&apos;: &apos;23,17&apos;, &apos;61&apos;: &apos;25,8&apos;, &apos;62&apos;: &apos;25,9&apos;, &apos;65&apos;: &apos;25,12&apos;, &apos;66&apos;: &apos;25,13&apos;, &apos;69&apos;: &apos;25,16&apos;, &apos;70&apos;: &apos;25,17&apos;, &apos;63&apos;: &apos;27,8&apos;, &apos;64&apos;: &apos;27,9&apos;, &apos;67&apos;: &apos;27,12&apos;, &apos;68&apos;: &apos;27,13&apos;, &apos;71&apos;: &apos;27,16&apos;, &apos;72&apos;: &apos;27,17&apos;, &apos;73&apos;: &apos;29,8&apos;, &apos;74&apos;: &apos;29,9&apos;, &apos;77&apos;: &apos;29,12&apos;, &apos;78&apos;: &apos;29,13&apos;, &apos;81&apos;: &apos;29,16&apos;, &apos;82&apos;: &apos;29,17&apos;, &apos;75&apos;: &apos;31,8&apos;, &apos;76&apos;: &apos;31,9&apos;, &apos;79&apos;: &apos;31,12&apos;, &apos;80&apos;: &apos;31,13&apos;, &apos;83&apos;: &apos;31,16&apos;, &apos;84&apos;: &apos;31,17&apos;, &apos;85&apos;: &apos;33,8&apos;, &apos;86&apos;: &apos;33,9&apos;, &apos;89&apos;: &apos;33,12&apos;, &apos;90&apos;: &apos;33,13&apos;, &apos;93&apos;: &apos;33,16&apos;, &apos;94&apos;: &apos;33,17&apos;, &apos;87&apos;: &apos;35,8&apos;, &apos;88&apos;: &apos;35,9&apos;, &apos;91&apos;: &apos;35,12&apos;, &apos;92&apos;: &apos;35,13&apos;, &apos;95&apos;: &apos;35,16&apos;, &apos;96&apos;: &apos;35,17&apos;, &apos;97&apos;: &apos;37,8&apos;, &apos;98&apos;: &apos;37,9&apos;, &apos;101&apos;: &apos;37,12&apos;, &apos;102&apos;: &apos;37,13&apos;, &apos;105&apos;: &apos;37,16&apos;, &apos;106&apos;: &apos;37,17&apos;, &apos;99&apos;: &apos;39,8&apos;, &apos;100&apos;: &apos;39,9&apos;, &apos;103&apos;: &apos;39,12&apos;, &apos;104&apos;: &apos;39,13&apos;, &apos;107&apos;: &apos;39,16&apos;, &apos;108&apos;: &apos;39,17&apos;, &apos;109&apos;: &apos;41,8&apos;, &apos;110&apos;: &apos;41,9&apos;, &apos;113&apos;: &apos;41,12&apos;, &apos;114&apos;: &apos;41,13&apos;, &apos;117&apos;: &apos;41,16&apos;, &apos;118&apos;: &apos;41,17&apos;, &apos;111&apos;: &apos;43,8&apos;, &apos;112&apos;: &apos;43,9&apos;, &apos;115&apos;: &apos;43,12&apos;, &apos;116&apos;: &apos;43,13&apos;, &apos;119&apos;: &apos;43,16&apos;, &apos;120&apos;: &apos;43,17&apos;&#125; # 五楼 R5_SEATTABLE=&#123;&apos;1&apos;: &apos;5,7&apos;, &apos;2&apos;: &apos;5,8&apos;, &apos;5&apos;: &apos;5,9&apos;, &apos;6&apos;: &apos;5,10&apos;, &apos;9&apos;: &apos;5,12&apos;, &apos;10&apos;: &apos;5,13&apos;, &apos;3&apos;: &apos;7,7&apos;, &apos;4&apos;: &apos;7,8&apos;, &apos;7&apos;: &apos;7,9&apos;, &apos;8&apos;: &apos;7,10&apos;, &apos;11&apos;: &apos;7,12&apos;, &apos;12&apos;: &apos;7,13&apos;, &apos;13&apos;: &apos;9,7&apos;, &apos;14&apos;: &apos;9,8&apos;, &apos;17&apos;: &apos;9,9&apos;, &apos;18&apos;: &apos;9,10&apos;, &apos;21&apos;: &apos;9,12&apos;, &apos;22&apos;: &apos;9,13&apos;, &apos;15&apos;: &apos;11,7&apos;, &apos;16&apos;: &apos;11,8&apos;, &apos;19&apos;: &apos;11,9&apos;, &apos;20&apos;: &apos;11,10&apos;, &apos;23&apos;: &apos;11,12&apos;, &apos;24&apos;: &apos;11,13&apos;, &apos;25&apos;: &apos;13,7&apos;, &apos;26&apos;: &apos;13,8&apos;, &apos;29&apos;: &apos;13,9&apos;, &apos;30&apos;: &apos;13,10&apos;, &apos;33&apos;: &apos;13,12&apos;, &apos;34&apos;: &apos;13,13&apos;, &apos;27&apos;: &apos;15,7&apos;, &apos;28&apos;: &apos;15,8&apos;, &apos;31&apos;: &apos;15,9&apos;, &apos;32&apos;: &apos;15,10&apos;, &apos;35&apos;: &apos;15,12&apos;, &apos;36&apos;: &apos;15,13&apos;, &apos;37&apos;: &apos;17,7&apos;, &apos;38&apos;: &apos;17,8&apos;, &apos;41&apos;: &apos;17,9&apos;, &apos;42&apos;: &apos;17,10&apos;, &apos;45&apos;: &apos;17,12&apos;, &apos;46&apos;: &apos;17,13&apos;, &apos;39&apos;: &apos;19,7&apos;, &apos;40&apos;: &apos;19,8&apos;, &apos;43&apos;: &apos;19,9&apos;, &apos;44&apos;: &apos;19,10&apos;, &apos;47&apos;: &apos;19,12&apos;, &apos;48&apos;: &apos;19,13&apos;, &apos;49&apos;: &apos;21,7&apos;, &apos;50&apos;: &apos;21,8&apos;, &apos;53&apos;: &apos;21,9&apos;, &apos;54&apos;: &apos;21,10&apos;, &apos;57&apos;: &apos;21,12&apos;, &apos;58&apos;: &apos;21,13&apos;, &apos;51&apos;: &apos;23,7&apos;, &apos;52&apos;: &apos;23,8&apos;, &apos;55&apos;: &apos;23,9&apos;, &apos;56&apos;: &apos;23,10&apos;, &apos;59&apos;: &apos;23,12&apos;, &apos;60&apos;: &apos;23,13&apos;, &apos;61&apos;: &apos;25,7&apos;, &apos;62&apos;: &apos;25,8&apos;, &apos;65&apos;: &apos;25,9&apos;, &apos;66&apos;: &apos;25,10&apos;, &apos;69&apos;: &apos;25,12&apos;, &apos;70&apos;: &apos;25,13&apos;, &apos;63&apos;: &apos;27,7&apos;, &apos;64&apos;: &apos;27,8&apos;, &apos;67&apos;: &apos;27,9&apos;, &apos;68&apos;: &apos;27,10&apos;, &apos;71&apos;: &apos;27,12&apos;, &apos;72&apos;: &apos;27,13&apos;, &apos;73&apos;: &apos;29,7&apos;, &apos;74&apos;: &apos;29,8&apos;, &apos;77&apos;: &apos;29,9&apos;, &apos;78&apos;: &apos;29,10&apos;, &apos;81&apos;: &apos;29,12&apos;, &apos;82&apos;: &apos;29,13&apos;, &apos;75&apos;: &apos;31,7&apos;, &apos;76&apos;: &apos;31,8&apos;, &apos;79&apos;: &apos;31,9&apos;, &apos;80&apos;: &apos;31,10&apos;, &apos;83&apos;: &apos;31,12&apos;, &apos;84&apos;: &apos;31,13&apos;, &apos;85&apos;: &apos;33,7&apos;, &apos;86&apos;: &apos;33,8&apos;, &apos;89&apos;: &apos;33,9&apos;, &apos;90&apos;: &apos;33,10&apos;, &apos;93&apos;: &apos;33,12&apos;, &apos;94&apos;: &apos;33,13&apos;, &apos;87&apos;: &apos;35,7&apos;, &apos;88&apos;: &apos;35,8&apos;, &apos;91&apos;: &apos;35,9&apos;, &apos;92&apos;: &apos;35,10&apos;, &apos;95&apos;: &apos;35,12&apos;, &apos;96&apos;: &apos;35,13&apos;, &apos;97&apos;: &apos;37,7&apos;, &apos;98&apos;: &apos;37,8&apos;, &apos;101&apos;: &apos;37,9&apos;, &apos;102&apos;: &apos;37,10&apos;, &apos;105&apos;: &apos;37,12&apos;, &apos;106&apos;: &apos;37,13&apos;, &apos;99&apos;: &apos;39,7&apos;, &apos;100&apos;: &apos;39,8&apos;, &apos;103&apos;: &apos;39,9&apos;, &apos;104&apos;: &apos;39,10&apos;, &apos;107&apos;: &apos;39,12&apos;, &apos;108&apos;: &apos;39,13&apos;, &apos;109&apos;: &apos;41,7&apos;, &apos;110&apos;: &apos;41,8&apos;, &apos;113&apos;: &apos;41,9&apos;, &apos;114&apos;: &apos;41,10&apos;, &apos;117&apos;: &apos;41,12&apos;, &apos;118&apos;: &apos;41,13&apos;, &apos;111&apos;: &apos;43,7&apos;, &apos;112&apos;: &apos;43,8&apos;, &apos;115&apos;: &apos;43,9&apos;, &apos;116&apos;: &apos;43,10&apos;, &apos;119&apos;: &apos;43,12&apos;, &apos;120&apos;: &apos;43,13&apos;&#125; # 六楼 R6_SEATTABLE=&#123;&apos;1&apos;: &apos;5,7&apos;, &apos;2&apos;: &apos;5,8&apos;, &apos;5&apos;: &apos;5,9&apos;, &apos;6&apos;: &apos;5,10&apos;, &apos;9&apos;: &apos;5,12&apos;, &apos;10&apos;: &apos;5,13&apos;, &apos;3&apos;: &apos;7,7&apos;, &apos;4&apos;: &apos;7,8&apos;, &apos;7&apos;: &apos;7,9&apos;, &apos;8&apos;: &apos;7,10&apos;, &apos;11&apos;: &apos;7,12&apos;, &apos;12&apos;: &apos;7,13&apos;, &apos;13&apos;: &apos;9,7&apos;, &apos;14&apos;: &apos;9,8&apos;, &apos;17&apos;: &apos;9,9&apos;, &apos;18&apos;: &apos;9,10&apos;, &apos;21&apos;: &apos;9,12&apos;, &apos;22&apos;: &apos;9,13&apos;, &apos;15&apos;: &apos;11,7&apos;, &apos;16&apos;: &apos;11,8&apos;, &apos;19&apos;: &apos;11,9&apos;, &apos;20&apos;: &apos;11,10&apos;, &apos;23&apos;: &apos;11,12&apos;, &apos;24&apos;: &apos;11,13&apos;, &apos;25&apos;: &apos;13,7&apos;, &apos;26&apos;: &apos;13,8&apos;, &apos;29&apos;: &apos;13,9&apos;, &apos;30&apos;: &apos;13,10&apos;, &apos;33&apos;: &apos;13,12&apos;, &apos;34&apos;: &apos;13,13&apos;, &apos;27&apos;: &apos;15,7&apos;, &apos;28&apos;: &apos;15,8&apos;, &apos;31&apos;: &apos;15,9&apos;, &apos;32&apos;: &apos;15,10&apos;, &apos;35&apos;: &apos;15,12&apos;, &apos;36&apos;: &apos;15,13&apos;, &apos;37&apos;: &apos;17,7&apos;, &apos;38&apos;: &apos;17,8&apos;, &apos;41&apos;: &apos;17,9&apos;, &apos;42&apos;: &apos;17,10&apos;, &apos;45&apos;: &apos;17,12&apos;, &apos;46&apos;: &apos;17,13&apos;, &apos;39&apos;: &apos;19,7&apos;, &apos;40&apos;: &apos;19,8&apos;, &apos;43&apos;: &apos;19,9&apos;, &apos;44&apos;: &apos;19,10&apos;, &apos;47&apos;: &apos;19,12&apos;, &apos;48&apos;: &apos;19,13&apos;, &apos;49&apos;: &apos;21,7&apos;, &apos;50&apos;: &apos;21,8&apos;, &apos;53&apos;: &apos;21,9&apos;, &apos;54&apos;: &apos;21,10&apos;, &apos;57&apos;: &apos;21,12&apos;, &apos;58&apos;: &apos;21,13&apos;, &apos;51&apos;: &apos;23,7&apos;, &apos;52&apos;: &apos;23,8&apos;, &apos;55&apos;: &apos;23,9&apos;, &apos;56&apos;: &apos;23,10&apos;, &apos;59&apos;: &apos;23,12&apos;, &apos;60&apos;: &apos;23,13&apos;, &apos;61&apos;: &apos;25,7&apos;, &apos;62&apos;: &apos;25,8&apos;, &apos;65&apos;: &apos;25,9&apos;, &apos;66&apos;: &apos;25,10&apos;, &apos;69&apos;: &apos;25,12&apos;, &apos;70&apos;: &apos;25,13&apos;, &apos;63&apos;: &apos;27,7&apos;, &apos;64&apos;: &apos;27,8&apos;, &apos;67&apos;: &apos;27,9&apos;, &apos;68&apos;: &apos;27,10&apos;, &apos;71&apos;: &apos;27,12&apos;, &apos;72&apos;: &apos;27,13&apos;, &apos;73&apos;: &apos;29,7&apos;, &apos;74&apos;: &apos;29,8&apos;, &apos;77&apos;: &apos;29,9&apos;, &apos;78&apos;: &apos;29,10&apos;, &apos;81&apos;: &apos;29,12&apos;, &apos;82&apos;: &apos;29,13&apos;, &apos;75&apos;: &apos;31,7&apos;, &apos;76&apos;: &apos;31,8&apos;, &apos;79&apos;: &apos;31,9&apos;, &apos;80&apos;: &apos;31,10&apos;, &apos;83&apos;: &apos;31,12&apos;, &apos;84&apos;: &apos;31,13&apos;, &apos;85&apos;: &apos;33,7&apos;, &apos;86&apos;: &apos;33,8&apos;, &apos;89&apos;: &apos;33,9&apos;, &apos;90&apos;: &apos;33,10&apos;, &apos;93&apos;: &apos;33,12&apos;, &apos;94&apos;: &apos;33,13&apos;, &apos;87&apos;: &apos;35,7&apos;, &apos;88&apos;: &apos;35,8&apos;, &apos;91&apos;: &apos;35,9&apos;, &apos;92&apos;: &apos;35,10&apos;, &apos;95&apos;: &apos;35,12&apos;, &apos;96&apos;: &apos;35,13&apos;, &apos;97&apos;: &apos;37,7&apos;, &apos;98&apos;: &apos;37,8&apos;, &apos;101&apos;: &apos;37,9&apos;, &apos;102&apos;: &apos;37,10&apos;, &apos;105&apos;: &apos;37,12&apos;, &apos;106&apos;: &apos;37,13&apos;, &apos;99&apos;: &apos;39,7&apos;, &apos;100&apos;: &apos;39,8&apos;, &apos;103&apos;: &apos;39,9&apos;, &apos;104&apos;: &apos;39,10&apos;, &apos;107&apos;: &apos;39,12&apos;, &apos;108&apos;: &apos;39,13&apos;, &apos;109&apos;: &apos;41,7&apos;, &apos;110&apos;: &apos;41,8&apos;, &apos;113&apos;: &apos;41,9&apos;, &apos;114&apos;: &apos;41,10&apos;, &apos;117&apos;: &apos;41,12&apos;, &apos;118&apos;: &apos;41,13&apos;, &apos;111&apos;: &apos;43,7&apos;, &apos;112&apos;: &apos;43,8&apos;, &apos;115&apos;: &apos;43,9&apos;, &apos;116&apos;: &apos;43,10&apos;, &apos;119&apos;: &apos;43,12&apos;, &apos;120&apos;: &apos;43,13&apos;&#125; 还是希望这些软件能够设计得更好吧，比较算是商用的了，轻松的获取了源码，还有很多信息未加密，太自信了。 最后也希望好好利用图书馆资源吧，不要占着那啥不那啥。 此致，敬礼]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
</search>
